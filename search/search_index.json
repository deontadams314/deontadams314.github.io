{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"welcome.html","text":"Welcome # Welcome to unknown-networks! # This blog was created because I need a spot where I can make tech related posts to teach others. I will be mainly discusing networkeng, cloud, code (python) & security related topics. Feel free to reach via social media and I hope you enjoy the content!","title":"Welcome"},{"location":"welcome.html#welcome","text":"","title":"Welcome"},{"location":"welcome.html#welcome-to-unknown-networks","text":"This blog was created because I need a spot where I can make tech related posts to teach others. I will be mainly discusing networkeng, cloud, code (python) & security related topics. Feel free to reach via social media and I hope you enjoy the content!","title":"Welcome to unknown-networks!"},{"location":"networking/General/2022-02-15-all-about-arp.html","text":"All About ARP # In today's article we will be discussing the Address Resolution Protocol, better known as ARP! ARP plays a key role in almost any type of network. If you are browsing the internet today there is a high chance ARP was involved in that process. Did you know that there are different types of ARP with different functions? Well hopefully after reading this you will gain some insight into the art of ARP! Address Resolution Protocol - ARP # Address Resolution Protocol is used to discover the physical MAC address of a host when the layer 3 network address is known. ARP is a layer 2 (data link) level protocol. We need ARP because even though the MAC address is unique to a host, the IP address could still change. For example let's say you had the IP address of Host A noted as 192.168.1.1. Well what if Host A's IP then changed to 192.168.1.2? How would you know where Host A is on the network now? This is why the MAC address msut be mapped to the IP address using ARP. ARP gathers information using a few different speaking tools. These are called ARP Reply and ARP Broadcast. An ARP Broadcast is a message sent out to the destination of FF:FF:FF:FF:FF:FF to everyone on the local subnet. This broadcast message is basically saying \"Hey what is the MAC address associated with 192.168.1.1?\". Hosts that do not have that IP address wil discard but the 192.168.1.1 host will use an ARP Reply and say \"Hey my MAC address is AB:CD:EF:01:23:45 I am 192.168.1.1\". The sender of the ARP Broadcast will receive this reply and update it's ARP Table with this new information. Now going forward the host will know the MAC address of the host associated with 192.168.1.1. The ARP Table will contain the mapping of the MAC address to the IP address as well the interface it was learned on and an expiration timer. Thr timer is a countdown and once it reaches 0 the entry will be flushed out of the ARP Table. This allows ARP entries to not become stale and to constantly keep up to date incase of IP network changes. Reverse Address Resolution Protocol - RARP # Reverse Address Resolution Protocol is used by certain hosts that by do not know their IP address and need to get it from a RARP server. The RARP server must be configured with the mapping of the MAC address of the host to an available IP address. The host will send a RARP broadcast message with their MAC address as the source. The RARP server will receive the broadcast and send a RARP reply with the IP address of the host. RARP is rarely used in todays networks as we have protocols such as DHCP in play now. Gratuitous Address Resolution Protocol # Gratuitous Address Resolution Protocol is used by a host to find it's own IP address on the network. Gratuitous ARP is essentially a method for duplicate IP detection. It is also a way to update hosts on the network with it's updated MAC-IP mapping. A host will send a broadcast message out with it's own IP as the soruce and destination. If an ARP reply is returned with it a source IP matching it's own, then there is a duplicate IP on the network. The source and destination IP address in the GARP broadcast will be the same since it is from the local host. Proxy Address Resolution Protocol # Proxy Address Resolution Protocol is a technique used to answer ARP requests on the behalf of another host. This Proxy ARP is typically used in scenarios where hosts are in the same IP space but not the same data link layer. A router will usually be the boarder or bridge between the hosts. When an ARP request is sent for a host on another data link the router reply with it's MAC address and forward & reply to requests for the IP address. Thus allowing the datagrams to be sent between the hosts.","title":"All About ARP"},{"location":"networking/General/2022-02-15-all-about-arp.html#all-about-arp","text":"In today's article we will be discussing the Address Resolution Protocol, better known as ARP! ARP plays a key role in almost any type of network. If you are browsing the internet today there is a high chance ARP was involved in that process. Did you know that there are different types of ARP with different functions? Well hopefully after reading this you will gain some insight into the art of ARP!","title":"All About ARP"},{"location":"networking/General/2022-02-15-all-about-arp.html#address-resolution-protocol-arp","text":"Address Resolution Protocol is used to discover the physical MAC address of a host when the layer 3 network address is known. ARP is a layer 2 (data link) level protocol. We need ARP because even though the MAC address is unique to a host, the IP address could still change. For example let's say you had the IP address of Host A noted as 192.168.1.1. Well what if Host A's IP then changed to 192.168.1.2? How would you know where Host A is on the network now? This is why the MAC address msut be mapped to the IP address using ARP. ARP gathers information using a few different speaking tools. These are called ARP Reply and ARP Broadcast. An ARP Broadcast is a message sent out to the destination of FF:FF:FF:FF:FF:FF to everyone on the local subnet. This broadcast message is basically saying \"Hey what is the MAC address associated with 192.168.1.1?\". Hosts that do not have that IP address wil discard but the 192.168.1.1 host will use an ARP Reply and say \"Hey my MAC address is AB:CD:EF:01:23:45 I am 192.168.1.1\". The sender of the ARP Broadcast will receive this reply and update it's ARP Table with this new information. Now going forward the host will know the MAC address of the host associated with 192.168.1.1. The ARP Table will contain the mapping of the MAC address to the IP address as well the interface it was learned on and an expiration timer. Thr timer is a countdown and once it reaches 0 the entry will be flushed out of the ARP Table. This allows ARP entries to not become stale and to constantly keep up to date incase of IP network changes.","title":"Address Resolution Protocol - ARP"},{"location":"networking/General/2022-02-15-all-about-arp.html#reverse-address-resolution-protocol-rarp","text":"Reverse Address Resolution Protocol is used by certain hosts that by do not know their IP address and need to get it from a RARP server. The RARP server must be configured with the mapping of the MAC address of the host to an available IP address. The host will send a RARP broadcast message with their MAC address as the source. The RARP server will receive the broadcast and send a RARP reply with the IP address of the host. RARP is rarely used in todays networks as we have protocols such as DHCP in play now.","title":"Reverse Address Resolution Protocol - RARP"},{"location":"networking/General/2022-02-15-all-about-arp.html#gratuitous-address-resolution-protocol","text":"Gratuitous Address Resolution Protocol is used by a host to find it's own IP address on the network. Gratuitous ARP is essentially a method for duplicate IP detection. It is also a way to update hosts on the network with it's updated MAC-IP mapping. A host will send a broadcast message out with it's own IP as the soruce and destination. If an ARP reply is returned with it a source IP matching it's own, then there is a duplicate IP on the network. The source and destination IP address in the GARP broadcast will be the same since it is from the local host.","title":"Gratuitous Address Resolution Protocol"},{"location":"networking/General/2022-02-15-all-about-arp.html#proxy-address-resolution-protocol","text":"Proxy Address Resolution Protocol is a technique used to answer ARP requests on the behalf of another host. This Proxy ARP is typically used in scenarios where hosts are in the same IP space but not the same data link layer. A router will usually be the boarder or bridge between the hosts. When an ARP request is sent for a host on another data link the router reply with it's MAC address and forward & reply to requests for the IP address. Thus allowing the datagrams to be sent between the hosts.","title":"Proxy Address Resolution Protocol"},{"location":"networking/General/2022-02-26-planes-data-control-management.html","text":"Planes: Control, Data, Management # Sorry to dissapoint but we will not be discussing the engineering behind a Boeing 747 in this blog post. Instead we will be discussing the Control, Data and Management planes. A network device is typically divided into 3 seperate portions of operation. These three planes all have different features and affect how a router functions. Let's dive in and see what exactly are these network planes and their purpose. Control Plane # The control plane's purpose is to determine the best pathway for a packet. Resources in the control plan handle the routing portion of a network device. Traffic from the control plane is sent to a router or originates from the router itself. The control plane is responsible for populating the routing table, which is used to populate the forwarding table. This means the data plane relies on the control plane to function. The control plain is known as the brain of the network due to this fact. Dynamic Routing Protocols (OSPF, BGP, ISIS etc), ICMP, ARP, DHCP, STP & LACP are some known control plane protocols. The control plane is software based and utilizes CPU rather than hardware like ASIC. Data Plane # The data plane's purpose is to forward the actual packets/frames from one interface to another. Switching is what occurs in the data plane rather than routing. The data plane will direct input packets to an output interface all based on the control planes routing logic. It is also known as the forwarding plane because it is responsible for moving packets from source to destination. Think of a packet that is passing in transit on the network as data plane traffic. The forwarding table (FIB), process switching & CEF switching are all data plane protocols and procedures. The data plane is hardware based utilizing hardware tools like ASIC and needs to be fast and have low latency. Management Plane # The management plane is traffic that used to manage/control the device on the network. The management protocols are typically used to monitor the device as well as for CLI access. The management plan is actually a subset of the control plane. This is because the destination of the traffic would be for the local device (ex. SSH to a router). SSH, SNMP, Telnet & FTP are examples of management plane protocols.","title":"Planes: Control, Data, Management"},{"location":"networking/General/2022-02-26-planes-data-control-management.html#planes-control-data-management","text":"Sorry to dissapoint but we will not be discussing the engineering behind a Boeing 747 in this blog post. Instead we will be discussing the Control, Data and Management planes. A network device is typically divided into 3 seperate portions of operation. These three planes all have different features and affect how a router functions. Let's dive in and see what exactly are these network planes and their purpose.","title":"Planes: Control, Data, Management"},{"location":"networking/General/2022-02-26-planes-data-control-management.html#control-plane","text":"The control plane's purpose is to determine the best pathway for a packet. Resources in the control plan handle the routing portion of a network device. Traffic from the control plane is sent to a router or originates from the router itself. The control plane is responsible for populating the routing table, which is used to populate the forwarding table. This means the data plane relies on the control plane to function. The control plain is known as the brain of the network due to this fact. Dynamic Routing Protocols (OSPF, BGP, ISIS etc), ICMP, ARP, DHCP, STP & LACP are some known control plane protocols. The control plane is software based and utilizes CPU rather than hardware like ASIC.","title":"Control Plane"},{"location":"networking/General/2022-02-26-planes-data-control-management.html#data-plane","text":"The data plane's purpose is to forward the actual packets/frames from one interface to another. Switching is what occurs in the data plane rather than routing. The data plane will direct input packets to an output interface all based on the control planes routing logic. It is also known as the forwarding plane because it is responsible for moving packets from source to destination. Think of a packet that is passing in transit on the network as data plane traffic. The forwarding table (FIB), process switching & CEF switching are all data plane protocols and procedures. The data plane is hardware based utilizing hardware tools like ASIC and needs to be fast and have low latency.","title":"Data Plane"},{"location":"networking/General/2022-02-26-planes-data-control-management.html#management-plane","text":"The management plane is traffic that used to manage/control the device on the network. The management protocols are typically used to monitor the device as well as for CLI access. The management plan is actually a subset of the control plane. This is because the destination of the traffic would be for the local device (ex. SSH to a router). SSH, SNMP, Telnet & FTP are examples of management plane protocols.","title":"Management Plane"},{"location":"networking/General/2022-02-28-stp.html","text":"STP: Spanning Tree Protocol 8012.1D # Spanning Tree Protocol (STP) is the tool used to prevent layer 2 switching loops on a network. STP is needed to prevent loops in layer 2 because frames do not have a Time To Live (TTL) header option. It works by placing switch ports into a forwarding or blocking state and notifying other switches of network changes. There are many different flavors of spanning tree but today we will only be discussing how it functions and some ways to optimize it. Let's take a deep dive so we can understand exactly how STP works. How does STP work? # STP uses messages called Bridge Protocol Data Units (BPDU) to stabilize the network and create a loop free topology. BPDUs are the ID of a switch on a network. They contain information on various timers as well as the identifer called the Bridge ID. The bridge ID is the priority number (0-65,535) + the MAC Address of a switch. STP enabled switches send each other BPDU's to figure out the root switch on a network. Once the root switch is found each switch will designate ports into root and designated ports. Any port that is not a root or designated port will be placed into a blocking state. Root Switch Election # Every switch on the network will send out BPDU hello packets that declare themself the root switch. If a BPDU is received on a segment with a lower bridge ID than its own, the switch will view that as the superior BPDU and no longer declare itself as root bridge. The switch will stop sending it's own BPDU hello packets and only forward the superior BPDU throughout the network. Eventually all switches in the network except the switch with the lowest bridge ID stop sending hellos. That one switch is the winner of the election is declared the root switch. Determining the Root Port # After the Root Switch is elected it should be the only switch sending out BPDU hello packets. Other non-root switches will receive the BPDU, add the cost of the interface it was recieved on to the BPDU cost and forward that BPDU out of it's other ports. That port which the BPDU was received on is declared the root port. The superior BPDU is also saved with the switch in order to keep track if there are any topology changes. The non-root switch at this point is forwarding the superior BPDU out of its designated ports (not the root port). Determining Designated Ports # The designated port is the non root port on the segment that is sending out the best BPDU hello packets. Designated ports are the only ports that forward BPDU hellos. There can be only one switch forwarding BPDUS on a segment. All other ports on a switch has been determined as root port or placed in the blocking state. PortFast / Edge Ports # PortFast/Edge is typically configured on ports where single hosts would connect to. PortFast allows for the port to transition immediately into the forwarding state. These port do not generate topology change events and can send BPDU's but is not expected to receieve them back. BPDU Guard # BPDU Guard is typically configured on the edge ports. This STP feature disables a port immediately if a BPDU is receieved. For example, if a rouge switch was plugged into an edge port that shouldnt be expected, BPDU guard can prevent any mischevious problems from occuring Root Guard # Root Guard will ignore any receieved superior BPDU's to prevent the port from becoming a root port. If a superior BPDU is receieved the switch poots the port into a root-inconsistent blocking state. This will stop the port from forwarding and receiving any data frames. Once the superior BPDU's stop the port will return to it's normal state. Root Guard allows the original root port to remain intact by disallowing a designated port to become the new root port.","title":"STP: Spanning Tree Protocol 8012.1D"},{"location":"networking/General/2022-02-28-stp.html#stp-spanning-tree-protocol-80121d","text":"Spanning Tree Protocol (STP) is the tool used to prevent layer 2 switching loops on a network. STP is needed to prevent loops in layer 2 because frames do not have a Time To Live (TTL) header option. It works by placing switch ports into a forwarding or blocking state and notifying other switches of network changes. There are many different flavors of spanning tree but today we will only be discussing how it functions and some ways to optimize it. Let's take a deep dive so we can understand exactly how STP works.","title":"STP: Spanning Tree Protocol 8012.1D"},{"location":"networking/General/2022-02-28-stp.html#how-does-stp-work","text":"STP uses messages called Bridge Protocol Data Units (BPDU) to stabilize the network and create a loop free topology. BPDUs are the ID of a switch on a network. They contain information on various timers as well as the identifer called the Bridge ID. The bridge ID is the priority number (0-65,535) + the MAC Address of a switch. STP enabled switches send each other BPDU's to figure out the root switch on a network. Once the root switch is found each switch will designate ports into root and designated ports. Any port that is not a root or designated port will be placed into a blocking state.","title":"How does STP work?"},{"location":"networking/General/2022-02-28-stp.html#root-switch-election","text":"Every switch on the network will send out BPDU hello packets that declare themself the root switch. If a BPDU is received on a segment with a lower bridge ID than its own, the switch will view that as the superior BPDU and no longer declare itself as root bridge. The switch will stop sending it's own BPDU hello packets and only forward the superior BPDU throughout the network. Eventually all switches in the network except the switch with the lowest bridge ID stop sending hellos. That one switch is the winner of the election is declared the root switch.","title":"Root Switch Election"},{"location":"networking/General/2022-02-28-stp.html#determining-the-root-port","text":"After the Root Switch is elected it should be the only switch sending out BPDU hello packets. Other non-root switches will receive the BPDU, add the cost of the interface it was recieved on to the BPDU cost and forward that BPDU out of it's other ports. That port which the BPDU was received on is declared the root port. The superior BPDU is also saved with the switch in order to keep track if there are any topology changes. The non-root switch at this point is forwarding the superior BPDU out of its designated ports (not the root port).","title":"Determining the Root Port"},{"location":"networking/General/2022-02-28-stp.html#determining-designated-ports","text":"The designated port is the non root port on the segment that is sending out the best BPDU hello packets. Designated ports are the only ports that forward BPDU hellos. There can be only one switch forwarding BPDUS on a segment. All other ports on a switch has been determined as root port or placed in the blocking state.","title":"Determining Designated Ports"},{"location":"networking/General/2022-02-28-stp.html#portfast-edge-ports","text":"PortFast/Edge is typically configured on ports where single hosts would connect to. PortFast allows for the port to transition immediately into the forwarding state. These port do not generate topology change events and can send BPDU's but is not expected to receieve them back.","title":"PortFast / Edge Ports"},{"location":"networking/General/2022-02-28-stp.html#bpdu-guard","text":"BPDU Guard is typically configured on the edge ports. This STP feature disables a port immediately if a BPDU is receieved. For example, if a rouge switch was plugged into an edge port that shouldnt be expected, BPDU guard can prevent any mischevious problems from occuring","title":"BPDU Guard"},{"location":"networking/General/2022-02-28-stp.html#root-guard","text":"Root Guard will ignore any receieved superior BPDU's to prevent the port from becoming a root port. If a superior BPDU is receieved the switch poots the port into a root-inconsistent blocking state. This will stop the port from forwarding and receiving any data frames. Once the superior BPDU's stop the port will return to it's normal state. Root Guard allows the original root port to remain intact by disallowing a designated port to become the new root port.","title":"Root Guard"},{"location":"networking/Routing/2022-01-27-bgp-states.html","text":"BGP States # INTRO # A BGP speaker has various states that it goes through before a neighbor adjacency is fully made. A finite state mechanism (FSM) is used to manage the states of each BGP peer during this process. FSM is a set of limited states that a BGP speaker is allowed to exist in during this process. BGP uses TCP for its connections so speakers listen on port 179. The first 3 states deal with the TCP side of the connection: IDLE, CONNECT, ACTIVE The other 3 deal with BGP application side: OPENSENT, OPENCONFIRM, ESTABLISHED Here we will discuss the many BGP states and hopefully you can walk away understanding the in's and out's of this process. IDLE # The IDLE state is the first stage of the BGP neighbor process. In this state the BGP speaker has been configured and is waiting for a start event. The speaker is basically waiting for a TCP connection to begin. Once started the speaker will transition into the CONNECT state. CONNECT # In the CONNECT state the BGP speaker is simply waiting for the TCP connection to be completed. If the TCP connection is succesfull the speaker transitions into the OPENSENT state, where the OPEN message is sent. If the TCP connection fails it will instead move into the ACTIVE state. If the ConnectRetry timer expires the connection will remain in the CONNECT state. ACTIVE # In the ACTIVE state the BGP speaker is listening for a BGP peer and trying to accept a TCP connection. If the TCP connection is successfull the speaker will transition into the OPENSENT state, where the OPEN message is sent. If the ConnectRetry timer expires the router will move back to the CONNECT state. If a device is stuck in the ACTIVE and CONNECT states usually this indicates a TCP issue and could be related to a firewall blocking the TCP port 179. OPENSENT # In the OPENSENT state is where the OPEN message will be sent and the speaker is also waiting to receive an OPEN message from its peer. The OPEN message is used to establish BGP peering connections and contains the following parameters BGP Version: The version of BGP used by the speaker AS #: Autonomous System # of the BGP speaker Hold Timer: The max time that can pass before a peer is declared dead. Once a keep alive is received if a response exceeds the hold timer the peer is considered dead. The lower of the two BGP speakers hold timers is used. 3 sec is the default. BGP ID - Identifier of the BGP speaker Optional - optional BGP parameters If the OPEN message contains no errors a KEEPALIVE message is sent and the speaker transitions into the OPENCONFIRM state. If the OPEN message has errors the state moves back to IDLE. OPENCONFIRM # In the OPENCONFIRM state the BGP speaker will wait for a KEEPALIVE. Once received it will transition into the ESTABLISHED state and the neighbor negotiation is sleep. If a NOTIFICATION error message is recieved then the state moves back into IDLE. ESTABLISHED # In the ESTABLISHED state is the final stage in the BGP process. At this point BGP update messages are shared between speakers as well as KEEPALIVES. The KEEPALIVE messages essentially check if a speaker is there and will reset the hold timer. If the hold timer expires the peer is considered dead and the state is moved back to IDLE. Any error or NOTIFICATION message will result in the speaker moving back into the IDLE state.","title":"BGP States"},{"location":"networking/Routing/2022-01-27-bgp-states.html#bgp-states","text":"","title":"BGP States"},{"location":"networking/Routing/2022-01-27-bgp-states.html#intro","text":"A BGP speaker has various states that it goes through before a neighbor adjacency is fully made. A finite state mechanism (FSM) is used to manage the states of each BGP peer during this process. FSM is a set of limited states that a BGP speaker is allowed to exist in during this process. BGP uses TCP for its connections so speakers listen on port 179. The first 3 states deal with the TCP side of the connection: IDLE, CONNECT, ACTIVE The other 3 deal with BGP application side: OPENSENT, OPENCONFIRM, ESTABLISHED Here we will discuss the many BGP states and hopefully you can walk away understanding the in's and out's of this process.","title":"INTRO"},{"location":"networking/Routing/2022-01-27-bgp-states.html#idle","text":"The IDLE state is the first stage of the BGP neighbor process. In this state the BGP speaker has been configured and is waiting for a start event. The speaker is basically waiting for a TCP connection to begin. Once started the speaker will transition into the CONNECT state.","title":"IDLE"},{"location":"networking/Routing/2022-01-27-bgp-states.html#connect","text":"In the CONNECT state the BGP speaker is simply waiting for the TCP connection to be completed. If the TCP connection is succesfull the speaker transitions into the OPENSENT state, where the OPEN message is sent. If the TCP connection fails it will instead move into the ACTIVE state. If the ConnectRetry timer expires the connection will remain in the CONNECT state.","title":"CONNECT"},{"location":"networking/Routing/2022-01-27-bgp-states.html#active","text":"In the ACTIVE state the BGP speaker is listening for a BGP peer and trying to accept a TCP connection. If the TCP connection is successfull the speaker will transition into the OPENSENT state, where the OPEN message is sent. If the ConnectRetry timer expires the router will move back to the CONNECT state. If a device is stuck in the ACTIVE and CONNECT states usually this indicates a TCP issue and could be related to a firewall blocking the TCP port 179.","title":"ACTIVE"},{"location":"networking/Routing/2022-01-27-bgp-states.html#opensent","text":"In the OPENSENT state is where the OPEN message will be sent and the speaker is also waiting to receive an OPEN message from its peer. The OPEN message is used to establish BGP peering connections and contains the following parameters BGP Version: The version of BGP used by the speaker AS #: Autonomous System # of the BGP speaker Hold Timer: The max time that can pass before a peer is declared dead. Once a keep alive is received if a response exceeds the hold timer the peer is considered dead. The lower of the two BGP speakers hold timers is used. 3 sec is the default. BGP ID - Identifier of the BGP speaker Optional - optional BGP parameters If the OPEN message contains no errors a KEEPALIVE message is sent and the speaker transitions into the OPENCONFIRM state. If the OPEN message has errors the state moves back to IDLE.","title":"OPENSENT"},{"location":"networking/Routing/2022-01-27-bgp-states.html#openconfirm","text":"In the OPENCONFIRM state the BGP speaker will wait for a KEEPALIVE. Once received it will transition into the ESTABLISHED state and the neighbor negotiation is sleep. If a NOTIFICATION error message is recieved then the state moves back into IDLE.","title":"OPENCONFIRM"},{"location":"networking/Routing/2022-01-27-bgp-states.html#established","text":"In the ESTABLISHED state is the final stage in the BGP process. At this point BGP update messages are shared between speakers as well as KEEPALIVES. The KEEPALIVE messages essentially check if a speaker is there and will reset the hold timer. If the hold timer expires the peer is considered dead and the state is moved back to IDLE. Any error or NOTIFICATION message will result in the speaker moving back into the IDLE state.","title":"ESTABLISHED"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html","text":"BGP Path Attributes # BGP uses a series of path attributes to make its routing decisions. This can affect how traffic is routed to or even how traffic is received from peers. Here we will take a look and discuss these path attributes to better understand how they can affec BGP behavior. AS_PATH # The AS_PATH attribute describes the autonomous systems that the network prefix (NLRI) has crossed. The AS numbers listed in the AS_PATH were prepended from other BGP speakers. AS_PATH can help prevent loops because if a BGP speaker see's it's own AS in the attribute path it will know to disregard the route. This attribute can also help influence incoming traffic by changing the AS path of it's advertised route. The BGP router will add it's own AS multiple times to the AS_PATH. This is know as AS Path Prepending . This is a well-known mandatory attribute. ORIGIN # The ORIGIN attribute tells the BGP speaker where the route originated from. There are 3 possible areas of origin for a NLRI. IGP: The route originated from a routing protocol internal to the originating AS. IGP has the highest preference. EGP: The route originated from the Exterior Gateway Protocol. This has the second highest preference. Incomplete: This means there is not enough information to determine where the route originated. This doesnt necessarily mean the route is bad just there is no way to determine the original source. This is a well-known mandatory attribute. NEXT_HOP # As the name suggests, the NEXT_HOP attribute will tell us the the IP address of the next hop router on the path to the destination. Keep in mind this will not always be the next hop neighbor. Here are 3 rules regarding this attribute. EBGP: If the advertising peer and receiving peer are in different AS, the NEXT_HOP will be the IP address of that advertising peer. IBGP_1: If the advertising peer is in the same AS and the prefix is in the same AS, then the NEXT_HOP will the be the IP address of the peer who advertised the route. IBGP_2: If the advertising peer are IBGP neighbors and the prefix was learned from another AS, the NEXT_HOP will be the ip address of external peer where the prefix was learned. This is a well-known mandatory attribute. LOCAL_PREF # LOCAL_PREF is an attribute that is only shared with iBGP neighbors not eBGP neighbors. The LOCAL_PREF does not leave the AS. A route will share the LOCAL_PREF to iBGP neighbors to dictate where traffic will be preffered. The highest LOCAL_PREF is preffered and chosen for those routes. Ths is a well-known discretionary attribute. MULTI_EXIT_DISC (MED) # The MULTI_EXIT_DISC can influence incoming traffic from external AS. This attribute is actually carried in EBGP update messages and will tell another AS its preferred ingress point. MEDs are only used to influence traffic between two directly connected AS and will not pass onto others. The lowest MED value is the preffred value for routes. This is an optional non-transitive attribute. ATOMIC_AGGREGATE & AGGREGATOR # The ATOMIC_AGGREGATE and AGGREGATOR are two seperate path attributes but go hand and hand. When routes are summarized and then advertised via BGP the AS_PATH information is lost on the route. The adveriser of the route removes all other AS#s and instead add it's own. The ATOMIC_AGGREGATE attribute is added to warn neighbors that \"Hey I am advertising a summarized route the AS info was lost\". The ATOMIC_AGGREGATE never leaves the route when passed onto other neighbors This is a well-known discretionary attribute. AGGREGATOR # The AGGREGATOR is an optional path attribute that a BGP speaker can use when when the ATOMIC_AGGREGATE has been set. This attribute provides information about wher the aggregation was performed. This will include the AS# and IP address of the router that originated the aggregate route. This is an optional transitive attribute. COMMUNITY # The COMMUNITY attribute can be used to tag routes to modify routing attiributes. For example I can tag routes from Group A all with a COMMUNITY attribute. This way I can change MED or LOCAL_PREF attributes based upon the COMMUNITY. There are 4 well known COMMUNITY groups Internet: All routes belong here by default. Routes can be advertised to all BGP neighbors. No-Advertise: Routes cannot be advertised at all. No-Export: Routes receiving this value cannot be advertised to eBGP peers. Local-AS: Routes with this cannot be advertised to eBGP peers and stay within the AS. This is an optional transitive attribute. ORIGINATOR_ID # ORIGINATOR_ID is used by route reflectors and used for preventing route loops. This is created by the route reflector and if the router see its RID in this attribute it knows to ignore the route because a loop has occured. This is an optional non-transitive attribute. CLUSTER_LIST # CLUSTER_LIST is also used by route reflectors. This is a sequence of route reflector ID's in which the route has passed through. If a route reflector see its local cluster ID here in a received route it, a loop has occured and the route is ignored. This is an optional non-transitive attribute. WEIGHT # This is a Cisco specific attribute that only exists on the local router. This is not shared with any other router. The weight can be assigned to a route the higher the weight the more preffered the route. Weight is considered above all attributes on Cisco devices. A number between 0-65,535 can be used for Weight.","title":"BGP Path Attributes"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#bgp-path-attributes","text":"BGP uses a series of path attributes to make its routing decisions. This can affect how traffic is routed to or even how traffic is received from peers. Here we will take a look and discuss these path attributes to better understand how they can affec BGP behavior.","title":"BGP Path Attributes"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#as_path","text":"The AS_PATH attribute describes the autonomous systems that the network prefix (NLRI) has crossed. The AS numbers listed in the AS_PATH were prepended from other BGP speakers. AS_PATH can help prevent loops because if a BGP speaker see's it's own AS in the attribute path it will know to disregard the route. This attribute can also help influence incoming traffic by changing the AS path of it's advertised route. The BGP router will add it's own AS multiple times to the AS_PATH. This is know as AS Path Prepending . This is a well-known mandatory attribute.","title":"AS_PATH"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#origin","text":"The ORIGIN attribute tells the BGP speaker where the route originated from. There are 3 possible areas of origin for a NLRI. IGP: The route originated from a routing protocol internal to the originating AS. IGP has the highest preference. EGP: The route originated from the Exterior Gateway Protocol. This has the second highest preference. Incomplete: This means there is not enough information to determine where the route originated. This doesnt necessarily mean the route is bad just there is no way to determine the original source. This is a well-known mandatory attribute.","title":"ORIGIN"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#next_hop","text":"As the name suggests, the NEXT_HOP attribute will tell us the the IP address of the next hop router on the path to the destination. Keep in mind this will not always be the next hop neighbor. Here are 3 rules regarding this attribute. EBGP: If the advertising peer and receiving peer are in different AS, the NEXT_HOP will be the IP address of that advertising peer. IBGP_1: If the advertising peer is in the same AS and the prefix is in the same AS, then the NEXT_HOP will the be the IP address of the peer who advertised the route. IBGP_2: If the advertising peer are IBGP neighbors and the prefix was learned from another AS, the NEXT_HOP will be the ip address of external peer where the prefix was learned. This is a well-known mandatory attribute.","title":"NEXT_HOP"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#local_pref","text":"LOCAL_PREF is an attribute that is only shared with iBGP neighbors not eBGP neighbors. The LOCAL_PREF does not leave the AS. A route will share the LOCAL_PREF to iBGP neighbors to dictate where traffic will be preffered. The highest LOCAL_PREF is preffered and chosen for those routes. Ths is a well-known discretionary attribute.","title":"LOCAL_PREF"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#multi_exit_disc-med","text":"The MULTI_EXIT_DISC can influence incoming traffic from external AS. This attribute is actually carried in EBGP update messages and will tell another AS its preferred ingress point. MEDs are only used to influence traffic between two directly connected AS and will not pass onto others. The lowest MED value is the preffred value for routes. This is an optional non-transitive attribute.","title":"MULTI_EXIT_DISC (MED)"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#atomic_aggregate-aggregator","text":"The ATOMIC_AGGREGATE and AGGREGATOR are two seperate path attributes but go hand and hand. When routes are summarized and then advertised via BGP the AS_PATH information is lost on the route. The adveriser of the route removes all other AS#s and instead add it's own. The ATOMIC_AGGREGATE attribute is added to warn neighbors that \"Hey I am advertising a summarized route the AS info was lost\". The ATOMIC_AGGREGATE never leaves the route when passed onto other neighbors This is a well-known discretionary attribute.","title":"ATOMIC_AGGREGATE &amp; AGGREGATOR"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#aggregator","text":"The AGGREGATOR is an optional path attribute that a BGP speaker can use when when the ATOMIC_AGGREGATE has been set. This attribute provides information about wher the aggregation was performed. This will include the AS# and IP address of the router that originated the aggregate route. This is an optional transitive attribute.","title":"AGGREGATOR"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#community","text":"The COMMUNITY attribute can be used to tag routes to modify routing attiributes. For example I can tag routes from Group A all with a COMMUNITY attribute. This way I can change MED or LOCAL_PREF attributes based upon the COMMUNITY. There are 4 well known COMMUNITY groups Internet: All routes belong here by default. Routes can be advertised to all BGP neighbors. No-Advertise: Routes cannot be advertised at all. No-Export: Routes receiving this value cannot be advertised to eBGP peers. Local-AS: Routes with this cannot be advertised to eBGP peers and stay within the AS. This is an optional transitive attribute.","title":"COMMUNITY"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#originator_id","text":"ORIGINATOR_ID is used by route reflectors and used for preventing route loops. This is created by the route reflector and if the router see its RID in this attribute it knows to ignore the route because a loop has occured. This is an optional non-transitive attribute.","title":"ORIGINATOR_ID"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#cluster_list","text":"CLUSTER_LIST is also used by route reflectors. This is a sequence of route reflector ID's in which the route has passed through. If a route reflector see its local cluster ID here in a received route it, a loop has occured and the route is ignored. This is an optional non-transitive attribute.","title":"CLUSTER_LIST"},{"location":"networking/Routing/2022-01-31-bgp-path-attributes.html#weight","text":"This is a Cisco specific attribute that only exists on the local router. This is not shared with any other router. The weight can be assigned to a route the higher the weight the more preffered the route. Weight is considered above all attributes on Cisco devices. A number between 0-65,535 can be used for Weight.","title":"WEIGHT"},{"location":"networking/Routing/2022-02-02-ibgp.html","text":"Internal BGP - iBGP # As most of you may know BGP has two modes external and internal BGP. Today we will be discussing iBGP and some important information about it. I personally think iBGP is very interesting and it's uses in todays enterprise networks is very fascinating. So without further ado lets dive in! What is iBGP? # Internal BGP is when BGP speakers are within the same autonomous system. This may cause some wide eyes because if you know eBGP uses the AS_PATH attribute to prevent loop prevention. iBGP Loop Prevention # How can iBGP prevent loops when they are in the same AS? Well iBGP has a few key rules that must be followed to prevent loops. iBGP peers cannot advertise routes learned from an iBGP peer to other iBGP peers. This means to learn routes peers participating in iBGP must be in a full mesh. This means every iBGP peer must peer with all other iBGP speakers. This would require an IGP used in conjuction with BGP to ensure connectivy is available for all peers to each other. Before a route learned from an iBGP peer is added to the BGP route table it also MUST exist in the IGP route table. Synchronization And iBGP # The Synchronization rule states that if an AS acts as a transit for another AS, BGP should not advertise a route until all routers within the AS have learned the route via an IGP. This makes sense because again remember all iBGP peers must be fully meshed. If they were not then black-hole route scenarios can occur due to not being able to route to specific peers. Synchronization can be an issue in modern networks. For example the entire BGP routing table would have to exist in the IGP. This can cause memory issues due to the size of the routing table and could end up crashing the router. Synchronization can be turned off however and a few design choices with pros & cons are made at that time. Synchronization can be used and every router will have to be fully meshed with the IGP must learn have external routes redistrubuted into it. Synchronization can be disabled without having the external routes in the IGP. This allows the routes to be added directly into the BGP table and you wont have to worry about overloading the IGP. Route Reflectors and Confederations can be used to resolve the fully mesh issue. Turning synchronization off is the preffered way to run iBGP.","title":"Internal BGP - iBGP"},{"location":"networking/Routing/2022-02-02-ibgp.html#internal-bgp-ibgp","text":"As most of you may know BGP has two modes external and internal BGP. Today we will be discussing iBGP and some important information about it. I personally think iBGP is very interesting and it's uses in todays enterprise networks is very fascinating. So without further ado lets dive in!","title":"Internal BGP - iBGP"},{"location":"networking/Routing/2022-02-02-ibgp.html#what-is-ibgp","text":"Internal BGP is when BGP speakers are within the same autonomous system. This may cause some wide eyes because if you know eBGP uses the AS_PATH attribute to prevent loop prevention.","title":"What is iBGP?"},{"location":"networking/Routing/2022-02-02-ibgp.html#ibgp-loop-prevention","text":"How can iBGP prevent loops when they are in the same AS? Well iBGP has a few key rules that must be followed to prevent loops. iBGP peers cannot advertise routes learned from an iBGP peer to other iBGP peers. This means to learn routes peers participating in iBGP must be in a full mesh. This means every iBGP peer must peer with all other iBGP speakers. This would require an IGP used in conjuction with BGP to ensure connectivy is available for all peers to each other. Before a route learned from an iBGP peer is added to the BGP route table it also MUST exist in the IGP route table.","title":"iBGP Loop Prevention"},{"location":"networking/Routing/2022-02-02-ibgp.html#synchronization-and-ibgp","text":"The Synchronization rule states that if an AS acts as a transit for another AS, BGP should not advertise a route until all routers within the AS have learned the route via an IGP. This makes sense because again remember all iBGP peers must be fully meshed. If they were not then black-hole route scenarios can occur due to not being able to route to specific peers. Synchronization can be an issue in modern networks. For example the entire BGP routing table would have to exist in the IGP. This can cause memory issues due to the size of the routing table and could end up crashing the router. Synchronization can be turned off however and a few design choices with pros & cons are made at that time. Synchronization can be used and every router will have to be fully meshed with the IGP must learn have external routes redistrubuted into it. Synchronization can be disabled without having the external routes in the IGP. This allows the routes to be added directly into the BGP table and you wont have to worry about overloading the IGP. Route Reflectors and Confederations can be used to resolve the fully mesh issue. Turning synchronization off is the preffered way to run iBGP.","title":"Synchronization And iBGP"},{"location":"networking/Routing/2022-02-04-route-reflectors-confederations.html","text":"Route Reflectors And Confederations # Today we will be discussing two different set of BGP related tools you can use to help scale and maintain a large BGP implementation. One is called Route Reflectors and the other is called Confederations. While these two names do sound like something out of Star Trek, please do not be afraid of them. They can make your large BGP setups become stress free (assuming you use them right :P). Lets take a dive! Route Reflectors # To understand Route Reflectors you must understand the problem they attempt to alleviate. In iBGP peers must exist in a fully meshed topology to insure no routing loops. Imagine an iBGP setup where you have 50+ routers in a full mesh - it would be a very tough situation to manage! With route reflectors you can have one router configured as a route reflector (RR) and other iBGP peers called clients. A router reflector and it's clients are known as a cluster. The RR can learn routes from its clients and advertise them to clients and non-clients. The clients can peer with other external neighbors or clients in the cluster. The RR can peer with both internal and external neighbors outside of the cluster. An AS can have multiple clusters and there also can be multiple RR for redundancy in the setup. Route Reflectors follow three rules to determine who the route is advertised to: If the route is learned from a non-client iBGP it is reflected to clients only If the route was learned from a client, it is reflected to all non-clients and clients (except for the originating client) If the route was learned from an eBGP - it is reflected to all clients and non-clients Due to the iBGP rule where internal neighbors cannot advertise routes learned from on internal router to another, route reflectors need a method in order to prevent routing loops. In order to do that RR's make use of two BGP path attributes: ORIGINATOR_ID & CLUSTER_LIST. The ORIGINATOR_ID is created by the route reflector and is the router-id (RID) of the originator of a route. If an RR sees an update with it's own RID the route is ignored. The CLUSTER_LIST is 4-octet number given to every cluster. When routes are reflected it is prepended with a cluster id just as an AS_PATH. If a RR sees its own cluster id in on the prefix it is dropped. Confederations # Confederations can help segment your AS into smaller sections. A confederation allows you to have sub-autonomous systems known as \"member autonomous systems\". A confederation receives an identifer called a confederation ID. This is what is actually spread to external AS systems - not the internal sub member AS numbers. There are two AS_PATH attributes added to confederations. They are called AS_CONFED_SEQUENCE and AS_CONFED_SET. AS_CONFED_SEQUENCE - Contains an ordered list of AS numbers along the path to the destination. These would be the internal sub member AS numbers. AS_CONFED_SET - Contains an unordered list of AS numbers along the path to the destination. These would be the internal sub member AS numbers. From the view of external numbers a confederation is just one AS system. They do not see the internal AS numbers of the confederationl. eBGP routes external to the confederation are preffered over eBGP routes to member AS systems, which is preffered over iBGP routes.","title":"Route Reflectors And Confederations"},{"location":"networking/Routing/2022-02-04-route-reflectors-confederations.html#route-reflectors-and-confederations","text":"Today we will be discussing two different set of BGP related tools you can use to help scale and maintain a large BGP implementation. One is called Route Reflectors and the other is called Confederations. While these two names do sound like something out of Star Trek, please do not be afraid of them. They can make your large BGP setups become stress free (assuming you use them right :P). Lets take a dive!","title":"Route Reflectors And Confederations"},{"location":"networking/Routing/2022-02-04-route-reflectors-confederations.html#route-reflectors","text":"To understand Route Reflectors you must understand the problem they attempt to alleviate. In iBGP peers must exist in a fully meshed topology to insure no routing loops. Imagine an iBGP setup where you have 50+ routers in a full mesh - it would be a very tough situation to manage! With route reflectors you can have one router configured as a route reflector (RR) and other iBGP peers called clients. A router reflector and it's clients are known as a cluster. The RR can learn routes from its clients and advertise them to clients and non-clients. The clients can peer with other external neighbors or clients in the cluster. The RR can peer with both internal and external neighbors outside of the cluster. An AS can have multiple clusters and there also can be multiple RR for redundancy in the setup. Route Reflectors follow three rules to determine who the route is advertised to: If the route is learned from a non-client iBGP it is reflected to clients only If the route was learned from a client, it is reflected to all non-clients and clients (except for the originating client) If the route was learned from an eBGP - it is reflected to all clients and non-clients Due to the iBGP rule where internal neighbors cannot advertise routes learned from on internal router to another, route reflectors need a method in order to prevent routing loops. In order to do that RR's make use of two BGP path attributes: ORIGINATOR_ID & CLUSTER_LIST. The ORIGINATOR_ID is created by the route reflector and is the router-id (RID) of the originator of a route. If an RR sees an update with it's own RID the route is ignored. The CLUSTER_LIST is 4-octet number given to every cluster. When routes are reflected it is prepended with a cluster id just as an AS_PATH. If a RR sees its own cluster id in on the prefix it is dropped.","title":"Route Reflectors"},{"location":"networking/Routing/2022-02-04-route-reflectors-confederations.html#confederations","text":"Confederations can help segment your AS into smaller sections. A confederation allows you to have sub-autonomous systems known as \"member autonomous systems\". A confederation receives an identifer called a confederation ID. This is what is actually spread to external AS systems - not the internal sub member AS numbers. There are two AS_PATH attributes added to confederations. They are called AS_CONFED_SEQUENCE and AS_CONFED_SET. AS_CONFED_SEQUENCE - Contains an ordered list of AS numbers along the path to the destination. These would be the internal sub member AS numbers. AS_CONFED_SET - Contains an unordered list of AS numbers along the path to the destination. These would be the internal sub member AS numbers. From the view of external numbers a confederation is just one AS system. They do not see the internal AS numbers of the confederationl. eBGP routes external to the confederation are preffered over eBGP routes to member AS systems, which is preffered over iBGP routes.","title":"Confederations"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html","text":"OSPF Neighbor States # OSPF is a rather complex routing protocol in the network world. Known as a link state routing protocol, OSPF maintains a link state database which is basically a topology of the network. OSPF routers have many states which they go through within the process of discovering peers, electing DR and BDRs and forming adjacensies. Here we will discuss these states which could possibly help you in the future if you ever had to troubleshoot them. Down # This is the initial OSPF state. In this form Hello messages have not been received from a peer. However they may be sent in this state. Attempt # This state is only valid in Non-Broadcast Multi Access (NBMA) netwoks where neighbors are manually configured. Hellos are sent to a neighbor at the HelloInterval interval timeframe. Init # In this state a Hello packet has been received from the neighbor but the recieving router has not seen its RID in the message. If a receiver sees it's own RID in the hello message, this is seen as an ACK that their hello message has been received by its peer. 2-Way # Bi-directional communication has been established in this state (each router has seen the others hello message). This is where the router decides if a full adjacency will be formed with its neighbor. OSPF routers only form full adjacencies with the Designated Router (DR) and Backup Designated Router (BDR) in broadcast and NBMA networks. The router will stay in the 2-Way state with all other neighbors. In broadcast and NBMA networks the DR & BDR are elected at the end of this state. ExStart # In this state routers from a master/slave relationship and determine the inital Database Description number. This will be used for the exchange of the Database Description packets. The router with the highest RID becomes the master. ExChange # In this state Database Description packets are exchanged which describe the link state database. Link state request packets can also be sent to request recent LSAs Loading # In this state the routers send Link State Request (LSR) packets to neighbors requesting more recent LSAs that have been discorved in the ExChange state but not yet recieved by the peer. Link State Updates (LSU) are sent to update any missing LSAs. Full # OSPF neighbors in this state are fully adjacent. All the router and network LSA's are exchanged with the LSD synchronized.","title":"OSPF Neighbor States"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#ospf-neighbor-states","text":"OSPF is a rather complex routing protocol in the network world. Known as a link state routing protocol, OSPF maintains a link state database which is basically a topology of the network. OSPF routers have many states which they go through within the process of discovering peers, electing DR and BDRs and forming adjacensies. Here we will discuss these states which could possibly help you in the future if you ever had to troubleshoot them.","title":"OSPF Neighbor States"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#down","text":"This is the initial OSPF state. In this form Hello messages have not been received from a peer. However they may be sent in this state.","title":"Down"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#attempt","text":"This state is only valid in Non-Broadcast Multi Access (NBMA) netwoks where neighbors are manually configured. Hellos are sent to a neighbor at the HelloInterval interval timeframe.","title":"Attempt"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#init","text":"In this state a Hello packet has been received from the neighbor but the recieving router has not seen its RID in the message. If a receiver sees it's own RID in the hello message, this is seen as an ACK that their hello message has been received by its peer.","title":"Init"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#2-way","text":"Bi-directional communication has been established in this state (each router has seen the others hello message). This is where the router decides if a full adjacency will be formed with its neighbor. OSPF routers only form full adjacencies with the Designated Router (DR) and Backup Designated Router (BDR) in broadcast and NBMA networks. The router will stay in the 2-Way state with all other neighbors. In broadcast and NBMA networks the DR & BDR are elected at the end of this state.","title":"2-Way"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#exstart","text":"In this state routers from a master/slave relationship and determine the inital Database Description number. This will be used for the exchange of the Database Description packets. The router with the highest RID becomes the master.","title":"ExStart"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#exchange","text":"In this state Database Description packets are exchanged which describe the link state database. Link state request packets can also be sent to request recent LSAs","title":"ExChange"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#loading","text":"In this state the routers send Link State Request (LSR) packets to neighbors requesting more recent LSAs that have been discorved in the ExChange state but not yet recieved by the peer. Link State Updates (LSU) are sent to update any missing LSAs.","title":"Loading"},{"location":"networking/Routing/2022-02-06-ospf-neighbor-states.html#full","text":"OSPF neighbors in this state are fully adjacent. All the router and network LSA's are exchanged with the LSD synchronized.","title":"Full"},{"location":"networking/Routing/2022-02-18-ospf-loop-prevention.html","text":"OSPF Loop Prevention # Recently I realized I had some questions on just how OSPF prevented loops. So as any curious mind would I did some research and decided to lab it up in GNS3. It was kind of difficult researching this topic online as there were very few examples online. Luckily I found a few and through some reading I was about to learn and expand my brain a bit. Before we can deep dive into how OSPF can prevent routing loops, we have to take a look at some OSPF basics. Specifically Area 0, OSPF LSA types and OSPF router roles such as the Area Border Router. OSPF Basics # OSPF is a link-state routing protocol that uses messages called Link State Advertisements (LSA) to share routing information. There are 11 different LSA packets but we will only be discussing the first three and how they work. LSA Type 1 - Router Sent between routers in a single area and does not leave the area of origin. Used to describe the cost of the link as well any neighboring routers on the link. LSA Type 2 - Network Originated by the Designated Router (DR) and like Type 1 LSAs are only flooded within a single area. Type 2 LSAs advertise information about all the connected routers (including the DR itself) in the network segment. LSA Type 3 - Summary Sent by the ABR to advertise the routes in another area. The ABR will send Type 3 LSAs to another area to describe the topology. The routers in the neighbor area will know to reach those routes via the ABR. The ABR also uses Type 3 LSAs to advertise destinations within its area to the backbone. OSPF Backbone Area & Area Border Routers # The backbone area (Area 0) is required when multiple areas are included within an OSPF topology. In order for one area to reach another area the traffic must pass through the backbone area. ABRs will send Type 3 LSAs through the backbone area which will be forwarded to the next area. This is important and one way OSPF prevents routing loops. Area Border Routers act as the middle man between the backbone and other areas. To be considered an ABR an interface must exist in both Area 0 and another area. ABR's expect Type 3 LSAs only from Area 0. Any Type 3 LSA recieved from a non-backbone area will be ignored. However an ABR will accept Type 3 LSA's if a router has a partial adjacency to Area 0 (which we will be testing). This doesn't necessarily mean those routes will be used so keep that in mind. Time To Lab # Here is the topology we will be working with in GNS3. As you can see we have 3 areas - Area 0, 1 and 2. How many ABR's do you see here? 2 or 3? R2 and R3 are ABR's but R5 is not. Remember to be considered an ABR you must have an interface located in the backbone area and an interface in another area. Taking a look at the \"show ospf border-routers\" command on R4 it seems to only recognize R2 as an ABR in Area 1, not R5. There is a route on R6 shared via OSPF for the address 66.66.66.66/32 sitting on router R6. The current path to this address is via R2, which makes sense because of the OSPF rule that traffic must pass through the backbone for inter-area traffic. What if we wanted to use the path through R5 instead? How can we make that happen? We can place an interface on R5 into Area 0! This will provide R5 with a partial adjacency to Area 0 and R4 will then see R5 as an ABR. The route for 66.66.66.66 should route through R5 at that point. We will place a loopback address on R5 into Area 0 to make this happen. There now that R5 has a connection to Area 0 let's take a look at R4 and see if it will route through R5. Nice! So it looks like a few things have occured on R4. It now views R5 as an ABR and was able to receive Type 3 LSA's from it. This caused the route to be added into the route table with a cost of 3 instead of 5! Finally the traceroute was performed and you can see it is now using the optimal path towards 66.66.66.66/32. But what about R2? R2 has a full adjacency with Area 0 and should have also received the Type 3 Summary LSA from R5. Will it now use the new path? if we take a look we can see it does not! ABR's only expect Type 3 LSA's from the backbone Area 0 and because R5 only has a partial adjacency to Area 0 it will not install that route into it's table and ignore it. Even though if we look at the OSPF database it has received the summary LSA from Area 1 it will only use the LSA from Area 0. To make R5 have a full adjacency to Area 0 you can create a virtual link to resolve the problem. A virtual link between R5 and R2 will allow R5 to connect with Area 0 and be viewed as a ABR. Here we will configure the virtual link between R5 & R2 using Area 1 as the transit area to the backbone. With the virtual link now configured between R5 & R2 lets check the if R2 can see R5 as an ABR. Wow would you look at that? R2 now considers the R5 and is using tha path through R5 to reach 66.66.66.66 instead of going through the backbone. R1 is also accepting the Type 3 LSAs from R5 as they are now being passed on by R2. What Did We Learn? # So we took a dive into OSPF loop prevention. We learned the purpose of the ABR and how it interacts with Type 3 LSA's coming from the non backbone areas. We also learned about virtual links and how to configure them. We saw that ABR routers will not pass on Type 3 LSA routes learned from non-backbone areas into the backbone. We gained a better understanding of how OSPF functions and the way the routers interact with each other based on the OSPF rules. Overall I felt this was a great lab and I encourage you to set up a topology like this to learn it yourself.","title":"OSPF Loop Prevention"},{"location":"networking/Routing/2022-02-18-ospf-loop-prevention.html#ospf-loop-prevention","text":"Recently I realized I had some questions on just how OSPF prevented loops. So as any curious mind would I did some research and decided to lab it up in GNS3. It was kind of difficult researching this topic online as there were very few examples online. Luckily I found a few and through some reading I was about to learn and expand my brain a bit. Before we can deep dive into how OSPF can prevent routing loops, we have to take a look at some OSPF basics. Specifically Area 0, OSPF LSA types and OSPF router roles such as the Area Border Router.","title":"OSPF Loop Prevention"},{"location":"networking/Routing/2022-02-18-ospf-loop-prevention.html#ospf-basics","text":"OSPF is a link-state routing protocol that uses messages called Link State Advertisements (LSA) to share routing information. There are 11 different LSA packets but we will only be discussing the first three and how they work. LSA Type 1 - Router Sent between routers in a single area and does not leave the area of origin. Used to describe the cost of the link as well any neighboring routers on the link. LSA Type 2 - Network Originated by the Designated Router (DR) and like Type 1 LSAs are only flooded within a single area. Type 2 LSAs advertise information about all the connected routers (including the DR itself) in the network segment. LSA Type 3 - Summary Sent by the ABR to advertise the routes in another area. The ABR will send Type 3 LSAs to another area to describe the topology. The routers in the neighbor area will know to reach those routes via the ABR. The ABR also uses Type 3 LSAs to advertise destinations within its area to the backbone.","title":"OSPF Basics"},{"location":"networking/Routing/2022-02-18-ospf-loop-prevention.html#ospf-backbone-area-area-border-routers","text":"The backbone area (Area 0) is required when multiple areas are included within an OSPF topology. In order for one area to reach another area the traffic must pass through the backbone area. ABRs will send Type 3 LSAs through the backbone area which will be forwarded to the next area. This is important and one way OSPF prevents routing loops. Area Border Routers act as the middle man between the backbone and other areas. To be considered an ABR an interface must exist in both Area 0 and another area. ABR's expect Type 3 LSAs only from Area 0. Any Type 3 LSA recieved from a non-backbone area will be ignored. However an ABR will accept Type 3 LSA's if a router has a partial adjacency to Area 0 (which we will be testing). This doesn't necessarily mean those routes will be used so keep that in mind.","title":"OSPF Backbone Area &amp; Area Border Routers"},{"location":"networking/Routing/2022-02-18-ospf-loop-prevention.html#time-to-lab","text":"Here is the topology we will be working with in GNS3. As you can see we have 3 areas - Area 0, 1 and 2. How many ABR's do you see here? 2 or 3? R2 and R3 are ABR's but R5 is not. Remember to be considered an ABR you must have an interface located in the backbone area and an interface in another area. Taking a look at the \"show ospf border-routers\" command on R4 it seems to only recognize R2 as an ABR in Area 1, not R5. There is a route on R6 shared via OSPF for the address 66.66.66.66/32 sitting on router R6. The current path to this address is via R2, which makes sense because of the OSPF rule that traffic must pass through the backbone for inter-area traffic. What if we wanted to use the path through R5 instead? How can we make that happen? We can place an interface on R5 into Area 0! This will provide R5 with a partial adjacency to Area 0 and R4 will then see R5 as an ABR. The route for 66.66.66.66 should route through R5 at that point. We will place a loopback address on R5 into Area 0 to make this happen. There now that R5 has a connection to Area 0 let's take a look at R4 and see if it will route through R5. Nice! So it looks like a few things have occured on R4. It now views R5 as an ABR and was able to receive Type 3 LSA's from it. This caused the route to be added into the route table with a cost of 3 instead of 5! Finally the traceroute was performed and you can see it is now using the optimal path towards 66.66.66.66/32. But what about R2? R2 has a full adjacency with Area 0 and should have also received the Type 3 Summary LSA from R5. Will it now use the new path? if we take a look we can see it does not! ABR's only expect Type 3 LSA's from the backbone Area 0 and because R5 only has a partial adjacency to Area 0 it will not install that route into it's table and ignore it. Even though if we look at the OSPF database it has received the summary LSA from Area 1 it will only use the LSA from Area 0. To make R5 have a full adjacency to Area 0 you can create a virtual link to resolve the problem. A virtual link between R5 and R2 will allow R5 to connect with Area 0 and be viewed as a ABR. Here we will configure the virtual link between R5 & R2 using Area 1 as the transit area to the backbone. With the virtual link now configured between R5 & R2 lets check the if R2 can see R5 as an ABR. Wow would you look at that? R2 now considers the R5 and is using tha path through R5 to reach 66.66.66.66 instead of going through the backbone. R1 is also accepting the Type 3 LSAs from R5 as they are now being passed on by R2.","title":"Time To Lab"},{"location":"networking/Routing/2022-02-18-ospf-loop-prevention.html#what-did-we-learn","text":"So we took a dive into OSPF loop prevention. We learned the purpose of the ABR and how it interacts with Type 3 LSA's coming from the non backbone areas. We also learned about virtual links and how to configure them. We saw that ABR routers will not pass on Type 3 LSA routes learned from non-backbone areas into the backbone. We gained a better understanding of how OSPF functions and the way the routers interact with each other based on the OSPF rules. Overall I felt this was a great lab and I encourage you to set up a topology like this to learn it yourself.","title":"What Did We Learn?"},{"location":"networking/Routing/2022-02-24-bgp-nwlla-omni.html","text":"BGP - N WLLA OMNI # I know what your thinking, N WLLA OMNI, is that weird dive bar that I should know about? No, N WLLA OMNI is the acronym for the BGP decision process. When a BGP router has multiple routes to an NLRI it must choose the best path to the NLRI. To figure out the best path this is where N WLLA OMNI comes into play. It is a rather deep system BGP uses to choose the best path. Here we will discuss the decision process in detail so it can become easier to understand and remember. The Decision Process # There are 9 total steps in the decision process with 3 additional tie-breaker steps. Let's take a look and see how BGP decides the best route to an NLRI when multiples exist. 1) Is the NEXT_HOP reachable?: If a router does not have a route next to the NEXT_HOP path atrribute, the route should then be rejected. 2) Highest Weight: Weight is a Cisco propriety feature so you will most likely not see this on other vendors. This attribute it set locally on the router to the NLRI and is not advertised to other routers. The higher the Weight the better the route. 3) Highest LOCAL_PREF: The higher the LOCAL_PREF the better the route. This is a well-known discretionary path attribute and is only used in iBGP. This attribute does not leave the AS and all routers within the AS can configure this attribute to choose the same exit route to an NLRI. 4) Locally Injected Routes: Choose the route locally injected into BGP (via network cmd, summarization or redistribution). Better than iBGP/eBGP learned routes. 5) Shortest AS_PATH length: AS_PATH is the attribute that shows the AS numbers that the NLRI has passed through. The shorter the AS_PATH the better the route. 6) ORIGIN attribute: IGP routes (I) are preferred over EGP (E) routes. Which is then preferred over incomplete (?) routes, You should rarely see EGP routes being BGP is the successor to EGP. 7) Smallest MED attribute: The smaller the MED value the better the route. The MED attribute is an optional transitive attribute. Typically a sender will use MED to tell a receiving peer with multiple connections to them the better pathway to an NLRI. 8) Neighbor Type: eBGP routes are preferred over iBGP routes. Confedration eBGP routes are treated as equal to iBGP. 9) IGP metric for reaching the NEXT_HOP: Compare the IGP metrics of the NEXT_HOP of an NLRI. The lower the metric the better the route. Tiebreaker Steps # If a best path is not determined after going through steps 1-9, 3 tiebreaker steps are used to find the best path to a NLRI. They are as follows: 10) Keeps the oldest eBGP route. If the routes being compared are eBGP routes and one of the paths is currently the best path, then keep that route as the best path. 11) Choose the route whose next-hop router ID (RID) is the smallest. 12) Choose the smallest neighbor ID. If a router has at least two neighbor connections with a single router, the router will prefer the route advertised by the lowest neighbor ID listed in the routers neighbor commands. N WLLA OMNI # The bread and better of the post and what we all have been waiting for. Here is the acronym used to help memorize this 9 step decision process. NEXT_HOP reachable? WEIGHT LOCAL_PREF Locally Injected AS_PATH length ORIGIN MED Neighbor Type IGP Metric to NEXT_HOP Key Things to Note # The decision process is only used to find one best path to reach an NLRI. It is not used to find multiple equal routes to install them into the routing table. If a step determines the best route the process ends at that step and does not move forward. For example, if LOCAL_PREF determines the best path it will not look at locally injected routes or AS_PATH.","title":"BGP - N WLLA OMNI"},{"location":"networking/Routing/2022-02-24-bgp-nwlla-omni.html#bgp-n-wlla-omni","text":"I know what your thinking, N WLLA OMNI, is that weird dive bar that I should know about? No, N WLLA OMNI is the acronym for the BGP decision process. When a BGP router has multiple routes to an NLRI it must choose the best path to the NLRI. To figure out the best path this is where N WLLA OMNI comes into play. It is a rather deep system BGP uses to choose the best path. Here we will discuss the decision process in detail so it can become easier to understand and remember.","title":"BGP - N WLLA OMNI"},{"location":"networking/Routing/2022-02-24-bgp-nwlla-omni.html#the-decision-process","text":"There are 9 total steps in the decision process with 3 additional tie-breaker steps. Let's take a look and see how BGP decides the best route to an NLRI when multiples exist. 1) Is the NEXT_HOP reachable?: If a router does not have a route next to the NEXT_HOP path atrribute, the route should then be rejected. 2) Highest Weight: Weight is a Cisco propriety feature so you will most likely not see this on other vendors. This attribute it set locally on the router to the NLRI and is not advertised to other routers. The higher the Weight the better the route. 3) Highest LOCAL_PREF: The higher the LOCAL_PREF the better the route. This is a well-known discretionary path attribute and is only used in iBGP. This attribute does not leave the AS and all routers within the AS can configure this attribute to choose the same exit route to an NLRI. 4) Locally Injected Routes: Choose the route locally injected into BGP (via network cmd, summarization or redistribution). Better than iBGP/eBGP learned routes. 5) Shortest AS_PATH length: AS_PATH is the attribute that shows the AS numbers that the NLRI has passed through. The shorter the AS_PATH the better the route. 6) ORIGIN attribute: IGP routes (I) are preferred over EGP (E) routes. Which is then preferred over incomplete (?) routes, You should rarely see EGP routes being BGP is the successor to EGP. 7) Smallest MED attribute: The smaller the MED value the better the route. The MED attribute is an optional transitive attribute. Typically a sender will use MED to tell a receiving peer with multiple connections to them the better pathway to an NLRI. 8) Neighbor Type: eBGP routes are preferred over iBGP routes. Confedration eBGP routes are treated as equal to iBGP. 9) IGP metric for reaching the NEXT_HOP: Compare the IGP metrics of the NEXT_HOP of an NLRI. The lower the metric the better the route.","title":"The Decision Process"},{"location":"networking/Routing/2022-02-24-bgp-nwlla-omni.html#tiebreaker-steps","text":"If a best path is not determined after going through steps 1-9, 3 tiebreaker steps are used to find the best path to a NLRI. They are as follows: 10) Keeps the oldest eBGP route. If the routes being compared are eBGP routes and one of the paths is currently the best path, then keep that route as the best path. 11) Choose the route whose next-hop router ID (RID) is the smallest. 12) Choose the smallest neighbor ID. If a router has at least two neighbor connections with a single router, the router will prefer the route advertised by the lowest neighbor ID listed in the routers neighbor commands.","title":"Tiebreaker Steps"},{"location":"networking/Routing/2022-02-24-bgp-nwlla-omni.html#n-wlla-omni","text":"The bread and better of the post and what we all have been waiting for. Here is the acronym used to help memorize this 9 step decision process. NEXT_HOP reachable? WEIGHT LOCAL_PREF Locally Injected AS_PATH length ORIGIN MED Neighbor Type IGP Metric to NEXT_HOP","title":"N WLLA OMNI"},{"location":"networking/Routing/2022-02-24-bgp-nwlla-omni.html#key-things-to-note","text":"The decision process is only used to find one best path to reach an NLRI. It is not used to find multiple equal routes to install them into the routing table. If a step determines the best route the process ends at that step and does not move forward. For example, if LOCAL_PREF determines the best path it will not look at locally injected routes or AS_PATH.","title":"Key Things to Note"},{"location":"networking/Routing/2022-03-01-routing-loops-prev.html","text":"Split Horizon/Posion Reverse/Route Poisoning # Today's topic is Split Horizon/Posion Reverse/Route Poisoning and we will discuss what they are and how routing is affected. Split Horizon is a method of preventing loops in distance-vector protocols. It works by not allowing a router to advertise a route back into the same interface it was learned on. For example router R1 learns the route 192.168.0.0/16 from R2 on its e0/0 interface. Due to split horizon it will not advertise that route back to R2 on it's e0/0 interface. Simple enough aint it? Split horizon is only used in distance-vector routing protocols. We can still take a look at different routing protocols and see how they prevent routing loops with similar network settings. OSPF - Split Horizon # OSPF actually doesn't use split horizon as it is a link-state protocol. OSPF uses the SPF algorithm to find the best bath to a route to maintain a loop free topology. The backbone Area 0 is utilized to maintain the loop free structure. OSPF has two major rules regarding the backbone area. For Intra-Area communication to occur the traffic must traverse the backbone area. ABR routers must disregard Type-3 Network LSAs from any non-backbone area and only accept them from area 0. BGP - Split Horizon # BGP has a split horizon rule that is specifically for iBGP. When an iBGP speaker receives a route from an internal peer, that iBGP speaker cannot advertise the route to other iBGP peers. This is because in iBGP the AS_PATH attribute is not modified due to the fact that the AS does not change. An internal iBGP peer could potentially advertise that route back to the originating peer or the route could be withdrawn and still exist in the network as valid. This is why iBGP requires a full mesh topology of BGP peers. This can be remedied with Router Reflectors or with Confederation setups. Poison Reverse # Poison Reverse is used in conjuction with Split Horizon and is actually the reverse of it. If a route is found to be invalid instead of not being advertised, it will be advertised with the infinite (\u221e) route metric. This ensures a path does not return back to the same router if the metric has changed. Route Poisoning # Route Poisoning is typically used in distance-vector protocols for loop prevention. If a route is detected to be unreachable it is given an infinite (\u221e) route metric and advertised to other routers in the network. The route is deemed invalid and unreachable at that point. RIP for example uses hop counts to determine the feasaibilty of a route. If the route reaches past the max hop count of 15 the route is invalid and route poisoning is used to let other routers now about this fact.","title":"Split Horizon/Posion Reverse/Route Poisoning"},{"location":"networking/Routing/2022-03-01-routing-loops-prev.html#split-horizonposion-reverseroute-poisoning","text":"Today's topic is Split Horizon/Posion Reverse/Route Poisoning and we will discuss what they are and how routing is affected. Split Horizon is a method of preventing loops in distance-vector protocols. It works by not allowing a router to advertise a route back into the same interface it was learned on. For example router R1 learns the route 192.168.0.0/16 from R2 on its e0/0 interface. Due to split horizon it will not advertise that route back to R2 on it's e0/0 interface. Simple enough aint it? Split horizon is only used in distance-vector routing protocols. We can still take a look at different routing protocols and see how they prevent routing loops with similar network settings.","title":"Split Horizon/Posion Reverse/Route Poisoning"},{"location":"networking/Routing/2022-03-01-routing-loops-prev.html#ospf-split-horizon","text":"OSPF actually doesn't use split horizon as it is a link-state protocol. OSPF uses the SPF algorithm to find the best bath to a route to maintain a loop free topology. The backbone Area 0 is utilized to maintain the loop free structure. OSPF has two major rules regarding the backbone area. For Intra-Area communication to occur the traffic must traverse the backbone area. ABR routers must disregard Type-3 Network LSAs from any non-backbone area and only accept them from area 0.","title":"OSPF - Split Horizon"},{"location":"networking/Routing/2022-03-01-routing-loops-prev.html#bgp-split-horizon","text":"BGP has a split horizon rule that is specifically for iBGP. When an iBGP speaker receives a route from an internal peer, that iBGP speaker cannot advertise the route to other iBGP peers. This is because in iBGP the AS_PATH attribute is not modified due to the fact that the AS does not change. An internal iBGP peer could potentially advertise that route back to the originating peer or the route could be withdrawn and still exist in the network as valid. This is why iBGP requires a full mesh topology of BGP peers. This can be remedied with Router Reflectors or with Confederation setups.","title":"BGP - Split Horizon"},{"location":"networking/Routing/2022-03-01-routing-loops-prev.html#poison-reverse","text":"Poison Reverse is used in conjuction with Split Horizon and is actually the reverse of it. If a route is found to be invalid instead of not being advertised, it will be advertised with the infinite (\u221e) route metric. This ensures a path does not return back to the same router if the metric has changed.","title":"Poison Reverse"},{"location":"networking/Routing/2022-03-01-routing-loops-prev.html#route-poisoning","text":"Route Poisoning is typically used in distance-vector protocols for loop prevention. If a route is detected to be unreachable it is given an infinite (\u221e) route metric and advertised to other routers in the network. The route is deemed invalid and unreachable at that point. RIP for example uses hop counts to determine the feasaibilty of a route. If the route reaches past the max hop count of 15 the route is invalid and route poisoning is used to let other routers now about this fact.","title":"Route Poisoning"},{"location":"networking/TCP-IP/2022-01-20-tcp-the-handshake.html","text":"TCP - The Handshake # You must crawl before you walk! Lets start with the basics and review everyone's favorite greeting - the 3 way handsake. How Is A Connection Established? # The sending side (known as the client) will send a SYN segment with the port number they want to connect to on the receiver (known as the server). This segment will also include the inital sequence number (ISN) of the client. The server will respond with a SYN that will include an ISN of it's own as well. The server will also acknowledge the clients SYN by sending an ACK segment with an ISN of the client plus one. A SYN will always consume one sequence number. The client will acknowledge the server's SYN with an ACK segment - again this will be equal to the clients SYN ISN plus one. The side that sends the first SYN is known to perform an active open . The receiver of the SYN that sends the next SYN performs a passive open . How Is A Connection Terminated? # Because a TCP connection is full-duplex each side must shut down independently. Usually the client will initate the closing of a TCP connection but the server can close as well. In total 4 segments are needed to close a connection. A connection can still be open in one direction and be closed in the other. This is known as a TCP half-close . This is basically saying \"Hey I would like to close my end of the connection - here is a FIN. But please still send data until I receive a FIN from the other side\" . A FIN will be sent by the side that wants to close their side of the session. This FIN will contain a sequence number of the current session. The receiver of this FIN will respond with an ACK of the sequence number plus one. A FIN consumes a sequence number just like SYN. At this point the other side will send a FIN segment to which the receiver must ACK to close the session on both ends. The side that sends the first FIN performs and active close . The side that receives that FIN performs a passive close .","title":"TCP - The Handshake"},{"location":"networking/TCP-IP/2022-01-20-tcp-the-handshake.html#tcp-the-handshake","text":"You must crawl before you walk! Lets start with the basics and review everyone's favorite greeting - the 3 way handsake.","title":"TCP - The Handshake"},{"location":"networking/TCP-IP/2022-01-20-tcp-the-handshake.html#how-is-a-connection-established","text":"The sending side (known as the client) will send a SYN segment with the port number they want to connect to on the receiver (known as the server). This segment will also include the inital sequence number (ISN) of the client. The server will respond with a SYN that will include an ISN of it's own as well. The server will also acknowledge the clients SYN by sending an ACK segment with an ISN of the client plus one. A SYN will always consume one sequence number. The client will acknowledge the server's SYN with an ACK segment - again this will be equal to the clients SYN ISN plus one. The side that sends the first SYN is known to perform an active open . The receiver of the SYN that sends the next SYN performs a passive open .","title":"How Is A Connection Established?"},{"location":"networking/TCP-IP/2022-01-20-tcp-the-handshake.html#how-is-a-connection-terminated","text":"Because a TCP connection is full-duplex each side must shut down independently. Usually the client will initate the closing of a TCP connection but the server can close as well. In total 4 segments are needed to close a connection. A connection can still be open in one direction and be closed in the other. This is known as a TCP half-close . This is basically saying \"Hey I would like to close my end of the connection - here is a FIN. But please still send data until I receive a FIN from the other side\" . A FIN will be sent by the side that wants to close their side of the session. This FIN will contain a sequence number of the current session. The receiver of this FIN will respond with an ACK of the sequence number plus one. A FIN consumes a sequence number just like SYN. At this point the other side will send a FIN segment to which the receiver must ACK to close the session on both ends. The side that sends the first FIN performs and active close . The side that receives that FIN performs a passive close .","title":"How Is A Connection Terminated?"},{"location":"networking/TCP-IP/2022-01-30-tcp-halfclose-halfopen.html","text":"TCP - Half-Close And Half-Open # Half-close and Half-open, what is this? And no these are not sequels in the Half-Life series =) - but rather TCP features that can occur due to its Full-Duplex nature. Here I will give you a few details about these two features so you can know the difference. Half-Close # A TCP half-close occurs when one side of the TCP connection closes it's side of the connection but can still receive data from the other end. A FIN is sent by the closing side and the receiver will ACK the FIN. Using a half-close has been looked at as being unreliable if needed for an extended period of time. This is because some devices like firewalls implement half-close timeouts. If the final FIN is not received within the timeout period the connection is then closed. Half-Open # A TCP half-open occurs when one of side of the TCP connection has crashed or forcibly closed without the otherside being notified. As long as no data is received the side that is till up will never know the other side is closed. Common causes for half-open's are device being powered off during a TCP connection.","title":"TCP - Half-Close And Half-Open"},{"location":"networking/TCP-IP/2022-01-30-tcp-halfclose-halfopen.html#tcp-half-close-and-half-open","text":"Half-close and Half-open, what is this? And no these are not sequels in the Half-Life series =) - but rather TCP features that can occur due to its Full-Duplex nature. Here I will give you a few details about these two features so you can know the difference.","title":"TCP - Half-Close And Half-Open"},{"location":"networking/TCP-IP/2022-01-30-tcp-halfclose-halfopen.html#half-close","text":"A TCP half-close occurs when one side of the TCP connection closes it's side of the connection but can still receive data from the other end. A FIN is sent by the closing side and the receiver will ACK the FIN. Using a half-close has been looked at as being unreliable if needed for an extended period of time. This is because some devices like firewalls implement half-close timeouts. If the final FIN is not received within the timeout period the connection is then closed.","title":"Half-Close"},{"location":"networking/TCP-IP/2022-01-30-tcp-halfclose-halfopen.html#half-open","text":"A TCP half-open occurs when one of side of the TCP connection has crashed or forcibly closed without the otherside being notified. As long as no data is received the side that is till up will never know the other side is closed. Common causes for half-open's are device being powered off during a TCP connection.","title":"Half-Open"},{"location":"networking/TCP-IP/2022-02-07-tcp-window.html","text":"The TCP Window # The Window Scale option is a TCP option used in modern TCP implementations. The maximum number of bytes allowed to be sent at once is 65,535. This is a problem and does not provide adequate traffic flow in todays networks. The problem to solve is todays topic - the window scale option! What is a TCP Window? # The TCP window is the maximum number of bytes that can be sent before an ACK is received. What does this mean exactly? Well both the client and server in a TCP connection will advertise in the SYN segment their window size. This is a buffer that the sender or receiver will use to determine how much data they can send/receive. The max number for the window size is 65,535. However if the TCP window scale is used this can be multiplied to a larger scale depending on what was set in the SYN segment. A TCP window is dynamic the size can increase or decrease within a TCP connection. What is Window Scaling? # Window scaling is a TCP option used to increase the flow of data in a TCP connection. As an option Window scaling is set in the SYN segment and advertised to the other side of the connection. Window scaling takes the window scale size and multiplies by a multiplier. This number is actual window for the send or receive buffer. What is a Sliding Window? # A sliding window allows the sender to transmit multiple segments within a given window size without receiving an ACK. The sliding window also keeps track of data ACK'd, data not ACK'd all in the availble window size. As data is ACK'd the window slides to the right depending on how fast it is consumed by the other end.","title":"The TCP Window"},{"location":"networking/TCP-IP/2022-02-07-tcp-window.html#the-tcp-window","text":"The Window Scale option is a TCP option used in modern TCP implementations. The maximum number of bytes allowed to be sent at once is 65,535. This is a problem and does not provide adequate traffic flow in todays networks. The problem to solve is todays topic - the window scale option!","title":"The TCP Window"},{"location":"networking/TCP-IP/2022-02-07-tcp-window.html#what-is-a-tcp-window","text":"The TCP window is the maximum number of bytes that can be sent before an ACK is received. What does this mean exactly? Well both the client and server in a TCP connection will advertise in the SYN segment their window size. This is a buffer that the sender or receiver will use to determine how much data they can send/receive. The max number for the window size is 65,535. However if the TCP window scale is used this can be multiplied to a larger scale depending on what was set in the SYN segment. A TCP window is dynamic the size can increase or decrease within a TCP connection.","title":"What is a TCP Window?"},{"location":"networking/TCP-IP/2022-02-07-tcp-window.html#what-is-window-scaling","text":"Window scaling is a TCP option used to increase the flow of data in a TCP connection. As an option Window scaling is set in the SYN segment and advertised to the other side of the connection. Window scaling takes the window scale size and multiplies by a multiplier. This number is actual window for the send or receive buffer.","title":"What is Window Scaling?"},{"location":"networking/TCP-IP/2022-02-07-tcp-window.html#what-is-a-sliding-window","text":"A sliding window allows the sender to transmit multiple segments within a given window size without receiving an ACK. The sliding window also keeps track of data ACK'd, data not ACK'd all in the availble window size. As data is ACK'd the window slides to the right depending on how fast it is consumed by the other end.","title":"What is a Sliding Window?"},{"location":"security/General/2022-04-10-how-tls-works.html","text":"How TLS Works # Today we will take a look at Transport Layer Security better known as its acronym TLS. TLS is an encryption protocol designed to ensure secure communication on a network. TLS replaced the original encryption protocol known as SSL (Secure Sockets Layer). However we still use the term SSL today but really they are referring to TLS. Let's take a look at how TLS functions and hopefully we can gain an understanding of this very important protocol. What is the TLS handshake? # The TLS Handshake is how two sides (client and server) agree between each other that TLS will be used to encrypt data during their communication. The TLS handshake occurs after the TCP connection has been successfully established. Once completed the TLS handshake is where the client and server will choose the TLS version, decide on cipher suites, exchange public keys, verify the SSL cert and generate sessions keys in order to use symmetric encryption after the handshake has been completed. As you can see a lot of information is passed between both sides during this sequence. Let's look at the actual steps in the next section. Steps in the TLS handshake # The exact steps in the TLS handshake can differ depending on the cipher suites supported between the client and server. Let's take a look at the RSA key exchange algorithm as that is used most often. Client Hello Message: Sent by the client and contains the following... TLS Version: The TLS versions supported by the client. These are listed in order of preference. Supported Cipher Suites: What cipher suites can the client use. These are listed in order of preference. Random Bytes: A string of random data generated by the client. This will be used to encrypt the data later. Session ID: The ID of the TLS connection. Compression Method: The method used for compressing the TLS packets to increase speed and lower bandwidth usage. Extensions: Extra TLS parameters that may be requested by the client. Server Hello Message: Response to the client hello message containg selected parameters from the client. TLS Version: The server selects a TLS version Cipher Suites: The server selects a cipher suite Random Bytes: The server creates a random 32-byte number of it's own to use later for encryption. Compression Method: The server selects a compression method Server Certificate: After the server hello message is sent it will send a \"Certificate\" message containing its SSL certificate. The public key is contained within the SSL cert. Server Key Exchange and Server Hello Done: The server key exchange is used to send the parameters that will be used to generate the symmetric key that will be used for encrypting data. The agreed upon protocol was Elliptic Curve Diffie- Hellman Ephemeral (ECDHE) in this example. The key parameters here to take note of are as follows.. Named Curve: The Elliptic curve selected by the server for computation. Public Key: The servers public key to be used by the client Signature: This value was signed using the private key of the server. The client will use the servers public key to verify that this belongs to the server. The Server Hello Done message is self explanatory and is the end of the Server Hello. Client Key Exchange and Change Cipher Spec: The server will exchange its public paramaters for the ECDHE algorithm. The Change Cipher Spec message is used to indicate that any message sent afterwards will be encrypted using the negotiated key and algorithm. Encrypted Handshake Message: This message is the final step of the TLS handshake and adds some protection from Man In The Middle (MITM) attacks. Protection from MITM is due to a HMAC-SHA256 of the master secret, hash of all messages and the finished label string is all contained here. Encrypted Application Data: At this point the TLS handshake is completed and all application data is encrypted. TLS Secrets # Pre-master Secret Generated by the client and encrytped using the public key from the server. This is sent over to the server via the Client Key Exchange mesage. The server will decrypt it with their private key. Once decrypted it is used to generate the Master Key. Master Secret The Client will generate the Master secret from the initial random keys generated in the client/server hello messages and the pre-master secret. The Master Secret is used to derive keys for symmetric encryption.","title":"How TLS Works"},{"location":"security/General/2022-04-10-how-tls-works.html#how-tls-works","text":"Today we will take a look at Transport Layer Security better known as its acronym TLS. TLS is an encryption protocol designed to ensure secure communication on a network. TLS replaced the original encryption protocol known as SSL (Secure Sockets Layer). However we still use the term SSL today but really they are referring to TLS. Let's take a look at how TLS functions and hopefully we can gain an understanding of this very important protocol.","title":"How TLS Works"},{"location":"security/General/2022-04-10-how-tls-works.html#what-is-the-tls-handshake","text":"The TLS Handshake is how two sides (client and server) agree between each other that TLS will be used to encrypt data during their communication. The TLS handshake occurs after the TCP connection has been successfully established. Once completed the TLS handshake is where the client and server will choose the TLS version, decide on cipher suites, exchange public keys, verify the SSL cert and generate sessions keys in order to use symmetric encryption after the handshake has been completed. As you can see a lot of information is passed between both sides during this sequence. Let's look at the actual steps in the next section.","title":"What is the TLS handshake?"},{"location":"security/General/2022-04-10-how-tls-works.html#steps-in-the-tls-handshake","text":"The exact steps in the TLS handshake can differ depending on the cipher suites supported between the client and server. Let's take a look at the RSA key exchange algorithm as that is used most often. Client Hello Message: Sent by the client and contains the following... TLS Version: The TLS versions supported by the client. These are listed in order of preference. Supported Cipher Suites: What cipher suites can the client use. These are listed in order of preference. Random Bytes: A string of random data generated by the client. This will be used to encrypt the data later. Session ID: The ID of the TLS connection. Compression Method: The method used for compressing the TLS packets to increase speed and lower bandwidth usage. Extensions: Extra TLS parameters that may be requested by the client. Server Hello Message: Response to the client hello message containg selected parameters from the client. TLS Version: The server selects a TLS version Cipher Suites: The server selects a cipher suite Random Bytes: The server creates a random 32-byte number of it's own to use later for encryption. Compression Method: The server selects a compression method Server Certificate: After the server hello message is sent it will send a \"Certificate\" message containing its SSL certificate. The public key is contained within the SSL cert. Server Key Exchange and Server Hello Done: The server key exchange is used to send the parameters that will be used to generate the symmetric key that will be used for encrypting data. The agreed upon protocol was Elliptic Curve Diffie- Hellman Ephemeral (ECDHE) in this example. The key parameters here to take note of are as follows.. Named Curve: The Elliptic curve selected by the server for computation. Public Key: The servers public key to be used by the client Signature: This value was signed using the private key of the server. The client will use the servers public key to verify that this belongs to the server. The Server Hello Done message is self explanatory and is the end of the Server Hello. Client Key Exchange and Change Cipher Spec: The server will exchange its public paramaters for the ECDHE algorithm. The Change Cipher Spec message is used to indicate that any message sent afterwards will be encrypted using the negotiated key and algorithm. Encrypted Handshake Message: This message is the final step of the TLS handshake and adds some protection from Man In The Middle (MITM) attacks. Protection from MITM is due to a HMAC-SHA256 of the master secret, hash of all messages and the finished label string is all contained here. Encrypted Application Data: At this point the TLS handshake is completed and all application data is encrypted.","title":"Steps in the TLS handshake"},{"location":"security/General/2022-04-10-how-tls-works.html#tls-secrets","text":"Pre-master Secret Generated by the client and encrytped using the public key from the server. This is sent over to the server via the Client Key Exchange mesage. The server will decrypt it with their private key. Once decrypted it is used to generate the Master Key. Master Secret The Client will generate the Master secret from the initial random keys generated in the client/server hello messages and the pre-master secret. The Master Secret is used to derive keys for symmetric encryption.","title":"TLS Secrets"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html","text":"VLAN Hopping # Welcome to the first part of a series that I figure most of you will love. In the NetSec series we will take a look a different network security concepts. This will include offense, defense, mitgation network security techniques. We will explore how it works and how we can defend against network attacks. The first concept of the NetSec series we will dive into is VLAN hopping. What is VLAN Hopping? # VLAN hopping is a network security attack where an attacker can gain access to traffic on a VLAN from another VLAN on the same network that might not necessarily be able to talk to each other. In order to take advantage of VLAN hopping an attacker must first breach one VLAN. Imagine a scenario where an attacker has access to a VOIP VLAN. They could potentially VLAN hop to your management VLAN or even a database VLAN with secret classified information. There are two ways to start a VLAN hopping attack, switch spoofing and double tagging. Switch Spoofing # Switch Spoofing is where an attacker takes advantage of Dynamic Trunking Protocol packets to negotiate a trunk port on a switch. By default switch ports are configured as dynamic auto or dynamic desirable. This will mean they will prefer the option to negotiate a trunk with another switch. Attackers take advantage of this by simply pluging their computer into a port and negotiate trunk link. At this point the attacker would have access to all VLANs on the network. Avoid configuring switch ports with the dynamic trunk options. Double Tagging # Double Tagging is where an attacker uses 802.1Q tagging in order to attack a VLAN. The attacker connected to a 802.1Q enabled port will send frames with an inner and outer VLAN tag. The outer tag is the actual VLAN the attacker is in. While the inner tag is the VLAN where the attacker wants to send the frame. The frame is able to be forwarded without the outer tag because it is the native vlan of the interface. This means the frame is sent to the target as if it is on the destination VLAN. This is a one way attack (good for DDOS attacks) and is only possible due to a switch using the native VLAN. Mitigation Techniques # Switch Spoofing - Switch ports should never be configured as dynamic switch ports. - Instead configure trunk ports with the \"nonegotiate\" option. - Ensure any port not meant to be a trunk port is configured as an access port. Double Tagging - Do not put any host onto VLAN 1 (the default native VLAN). - Change the native VLAN on any trunk port to an unused VLAN on the network. How do hackers perform this attack? # Attackers can use a linux based tool called Yersinia. Yersinia allows an attacker to send DTP frames. It has many tools for layer 2 based network attacks. Scapy can be used for Double Tagging. A hacker can craft the doubel tagged frames in Python.","title":"VLAN Hopping"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html#vlan-hopping","text":"Welcome to the first part of a series that I figure most of you will love. In the NetSec series we will take a look a different network security concepts. This will include offense, defense, mitgation network security techniques. We will explore how it works and how we can defend against network attacks. The first concept of the NetSec series we will dive into is VLAN hopping.","title":"VLAN Hopping"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html#what-is-vlan-hopping","text":"VLAN hopping is a network security attack where an attacker can gain access to traffic on a VLAN from another VLAN on the same network that might not necessarily be able to talk to each other. In order to take advantage of VLAN hopping an attacker must first breach one VLAN. Imagine a scenario where an attacker has access to a VOIP VLAN. They could potentially VLAN hop to your management VLAN or even a database VLAN with secret classified information. There are two ways to start a VLAN hopping attack, switch spoofing and double tagging.","title":"What is VLAN Hopping?"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html#switch-spoofing","text":"Switch Spoofing is where an attacker takes advantage of Dynamic Trunking Protocol packets to negotiate a trunk port on a switch. By default switch ports are configured as dynamic auto or dynamic desirable. This will mean they will prefer the option to negotiate a trunk with another switch. Attackers take advantage of this by simply pluging their computer into a port and negotiate trunk link. At this point the attacker would have access to all VLANs on the network. Avoid configuring switch ports with the dynamic trunk options.","title":"Switch Spoofing"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html#double-tagging","text":"Double Tagging is where an attacker uses 802.1Q tagging in order to attack a VLAN. The attacker connected to a 802.1Q enabled port will send frames with an inner and outer VLAN tag. The outer tag is the actual VLAN the attacker is in. While the inner tag is the VLAN where the attacker wants to send the frame. The frame is able to be forwarded without the outer tag because it is the native vlan of the interface. This means the frame is sent to the target as if it is on the destination VLAN. This is a one way attack (good for DDOS attacks) and is only possible due to a switch using the native VLAN.","title":"Double Tagging"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html#mitigation-techniques","text":"Switch Spoofing - Switch ports should never be configured as dynamic switch ports. - Instead configure trunk ports with the \"nonegotiate\" option. - Ensure any port not meant to be a trunk port is configured as an access port. Double Tagging - Do not put any host onto VLAN 1 (the default native VLAN). - Change the native VLAN on any trunk port to an unused VLAN on the network.","title":"Mitigation Techniques"},{"location":"security/Network-Security/2022-04-18-netsec-vlan-hopping.html#how-do-hackers-perform-this-attack","text":"Attackers can use a linux based tool called Yersinia. Yersinia allows an attacker to send DTP frames. It has many tools for layer 2 based network attacks. Scapy can be used for Double Tagging. A hacker can craft the doubel tagged frames in Python.","title":"How do hackers perform this attack?"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html","text":"ARP Spoofing # In todays article in the NetSec series we will be discussing another layer 2 network attack, ARP Spoofing. ARP Spoofing also goes by the name ARP Cache Poisoning/ARP Poisoning. To understand how an ARP Spoofing attack works we must understand how Address Resolution Protocol (ARP) functions. I won't talk too much here, let's dive in! How does ARP work? # Address Resolution Protocol allows a host to find another host on a network. Before a host can send a layer 3 packet to a destination they must have the MAC address of the destination host. To simply put ARP translates IPv4 addresses to MAC addresses. Every host on a network maintains an ARP cache which contains the mappings of IP addresses to MAC addrreses and the interface used to reach that host. If a host doesn't know the MAC address for a certain IP, an ARP broadcast message is sent on the network asking \"Who does this IP belong to?\". The host who has the IP address will respond with it's MAC address and that will be captured in the requesters ARP cache. ARP unfortunately does not have any built in security mechanisms. This would allow anyone to respond to an ARP request with no way to verify if the information is correct. ARP also allows hosts send ARP replies without it even being requested. These two downfalls is what allows ARP Spoofing attacks to work and wreck havoc on a network. What is ARP Spoofing? # ARP Spoofing is a layer 2 Man In The Middle (MitM) Attack that takes advantage of the lack of security in the ARP protocol. In order for ARP Spoofing to work an attacker must already have access on the network. Once on the network the attacker would identify a host or hosts on the network and use a tool to forge ARP responses. These reponses would claim the attackers MAC address as the MAC address of the target host(s). Other devices on the network would have no way to verify this and simply update their ARP cache with the MAC address of the attacker. At this point the attacker may inspect the packets being sent while forwarding to the actual destination to avoid detection. They may even steal information from the packets that have recieved or modify the data. How can I detect an ARP Spoofing attack? # A host can detect ARP Spoofing on an network by checking and verifying the ARP cache on your machine. If you see the same MAC address on different IP addreses this could be a sign of ARP Spoofing taking place. Using WireShark to sniff the traffic on your network can also determine patterns and help you find a potential spoofer. Mitigation Techniques # There are a few ways that a network admin can fight against ARP Spoofing - Static ARP Entries - Use static ARP entries for critical hosts (DNS servers, routers, load balancers etc.). This however does not scale on a large network as the entries would need to be entered mantained on each host on the network. - OS Security Settings - Each OS behaves differently and has built in defense settings that can be used to combat ARP Spoofing. - ARP Detection & Prevention Software - 3rd party software can be put in place on host machines to detect ARP Spoofing - Packet Filtering - Use packet filtering to verify if packets contain conflicting source information. How do hackers perform this attack? # There are a multiple tools an attacker can use to spoof ARP responses. A few include: - ARPspoof - Arpoision - Cain and Abel","title":"ARP Spoofing"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html#arp-spoofing","text":"In todays article in the NetSec series we will be discussing another layer 2 network attack, ARP Spoofing. ARP Spoofing also goes by the name ARP Cache Poisoning/ARP Poisoning. To understand how an ARP Spoofing attack works we must understand how Address Resolution Protocol (ARP) functions. I won't talk too much here, let's dive in!","title":"ARP Spoofing"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html#how-does-arp-work","text":"Address Resolution Protocol allows a host to find another host on a network. Before a host can send a layer 3 packet to a destination they must have the MAC address of the destination host. To simply put ARP translates IPv4 addresses to MAC addresses. Every host on a network maintains an ARP cache which contains the mappings of IP addresses to MAC addrreses and the interface used to reach that host. If a host doesn't know the MAC address for a certain IP, an ARP broadcast message is sent on the network asking \"Who does this IP belong to?\". The host who has the IP address will respond with it's MAC address and that will be captured in the requesters ARP cache. ARP unfortunately does not have any built in security mechanisms. This would allow anyone to respond to an ARP request with no way to verify if the information is correct. ARP also allows hosts send ARP replies without it even being requested. These two downfalls is what allows ARP Spoofing attacks to work and wreck havoc on a network.","title":"How does ARP work?"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html#what-is-arp-spoofing","text":"ARP Spoofing is a layer 2 Man In The Middle (MitM) Attack that takes advantage of the lack of security in the ARP protocol. In order for ARP Spoofing to work an attacker must already have access on the network. Once on the network the attacker would identify a host or hosts on the network and use a tool to forge ARP responses. These reponses would claim the attackers MAC address as the MAC address of the target host(s). Other devices on the network would have no way to verify this and simply update their ARP cache with the MAC address of the attacker. At this point the attacker may inspect the packets being sent while forwarding to the actual destination to avoid detection. They may even steal information from the packets that have recieved or modify the data.","title":"What is ARP Spoofing?"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html#how-can-i-detect-an-arp-spoofing-attack","text":"A host can detect ARP Spoofing on an network by checking and verifying the ARP cache on your machine. If you see the same MAC address on different IP addreses this could be a sign of ARP Spoofing taking place. Using WireShark to sniff the traffic on your network can also determine patterns and help you find a potential spoofer.","title":"How can I detect an ARP Spoofing attack?"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html#mitigation-techniques","text":"There are a few ways that a network admin can fight against ARP Spoofing - Static ARP Entries - Use static ARP entries for critical hosts (DNS servers, routers, load balancers etc.). This however does not scale on a large network as the entries would need to be entered mantained on each host on the network. - OS Security Settings - Each OS behaves differently and has built in defense settings that can be used to combat ARP Spoofing. - ARP Detection & Prevention Software - 3rd party software can be put in place on host machines to detect ARP Spoofing - Packet Filtering - Use packet filtering to verify if packets contain conflicting source information.","title":"Mitigation Techniques"},{"location":"security/Network-Security/2022-04-19-netsec-arp-spoofing.html#how-do-hackers-perform-this-attack","text":"There are a multiple tools an attacker can use to spoof ARP responses. A few include: - ARPspoof - Arpoision - Cain and Abel","title":"How do hackers perform this attack?"},{"location":"security/Network-Security/2022-04-20-netsec-ddos-attacks.html","text":"DDoS Attacks # Happy 4/20 =]! Today we will be talking about a commonly heard network attack, DDoS attacks. Here we will discuss the different types of DDoS attacks, how they work and different ways we can possibly mitigate them. I still remember the DDoS attack that took down the Playstation Network for a couple days during a holiday. No more chatting lets dive in! What is a DDoS Attack? # A Distributed Denial of Service (DDoS) attack is a malicious network attack whose goal is to stop or interrupt an online application or service by overloading it's system. DDoS attacks are calculated and usualy come from multiple compromised hosts called a Bot Army. Each device is used to flood a service with a specific type of traffic. DDoS attacks can be split into 3 different category types: - Volume Based Attacks - This attacks goal is to saturate the bandwidth of an attacked site. - UDP Floods, ICMP Floods and spoof-based attackeds are Volume attacks. - Measured in Bps (Bits per second) - Protocol Attacks - Protocol based attacks aim to consume up a victims resources. - SYN Flood, Ping of Death, Smurf DDoS are Protocol Attacks. - Measured in Pps (Packets per second) - Application Layer Attacks - Application Layer attacks aim to crash the web server - GET/POST Floods and typically attack Nginx, Apache, Windows, Linux based vulenerabilities. - Measuered in Rps (Requests per second) Types of DDoS Attacks # UDP Flood Floods a target with UDP packets on random ports on a host. This forces the host constantly check the application for the connection and when it doesnt find an active session it will respond with an ICMP \u2018Destination Unreachable\u2019 packet. This drains the resources of the target host. SYN Flood Floods a target with TCP SYN requests packets. This causes the host to respond with a SYN-ACK packet. The target ends ups waiting forever for an ACK from the attacker causing resources to be tied up until no new connections can be made. HTTP Flood Floods a target with GET or POST HTTP requests. These look legit so it is hard for a target host to determine what is legit or not. The goal is take utilize the resources on a host. ICMP Flood Overwhelms a target with ICMP Echo Request (ping) packets. The target host will attempt to reply to the attacker with ICMP Reply packets causing exhaustion of bandwidth and internal resources. Ping of Death (POD) The max size of an IP packet is 65,535 bytes. The data-link layer typically has a max frame size of 1500 bytes. This means a large IP packet has to be broken down into multiple fragments and then reassembled by the target host. If a host attempts to reassemble a packet larger than 65,535 bytes mememory buffer overflow errors can occur. Slowloris Allows a single computer to take down a webhost. Slowloris works by opening multiple connections to a web server and keeping them open as long as possible. Slowloris sends multiple HTTP headers for each request and never looks to complete the request. Eventually the connection pool on a host is filled and the target host can no longer accept new connections. Slowloris as the name states is meant to be a slow working attack. NTP Amplification An attacker will exploit a public NTP server and overhelm a victim host with UDP traffic. The amplification is due the fact that a compromised NTP host can easily send a very high amount of UDP traffic resulting in a high bandwidth & high volume attack. Smurf DDoS An attacker spoofs an IP address and sends an ICMP request to a victim. The victim will send a ICMP reply to which the attacker will echo the response back to the victim. This creates an infinite loop and eventually crashes the system. Mitigation Techniques # There are many ways to mitigate a DDoS attack. Even more than listed here. I believe a good combination of a few in conjuction will help round out your networks defense to a DDoS attack. Anycast Network Anycast allows different servers to share the same IP address. BGP allows hosts to find the best route to the nearest anycast address. Anycast networks allows network traffic to be spread out. A DDoS attack would have to take down every server in the anycast network. Firewall & Network Monitoring Configure firewall to protect against flood attacks. Monitor traffic so you can keep traffic of patterns and determine when an attack is possible. Cloud Multi Region Hosted Application Have an application configured to work in different physical regions this way the blast radius would be large for a DDoS attack. Utilize BGP with an ISP Work with an ISP to route traffic away when a DDoS attack is detected. Upstream filtering Cloudflare or Amazon Shield work by checking incoming packet IPs against known attackers and BotNets and attempt to only forward legitimate traffic. Stops the attack before it reaches your network. CDN Network Avoids a single point of congestion by having multiple PoPs. Distributes content across the globe or regions. Anti DDoS Systems Arbor Networks, Akamai, CloudFlare, Radware","title":"DDoS Attacks"},{"location":"security/Network-Security/2022-04-20-netsec-ddos-attacks.html#ddos-attacks","text":"Happy 4/20 =]! Today we will be talking about a commonly heard network attack, DDoS attacks. Here we will discuss the different types of DDoS attacks, how they work and different ways we can possibly mitigate them. I still remember the DDoS attack that took down the Playstation Network for a couple days during a holiday. No more chatting lets dive in!","title":"DDoS Attacks"},{"location":"security/Network-Security/2022-04-20-netsec-ddos-attacks.html#what-is-a-ddos-attack","text":"A Distributed Denial of Service (DDoS) attack is a malicious network attack whose goal is to stop or interrupt an online application or service by overloading it's system. DDoS attacks are calculated and usualy come from multiple compromised hosts called a Bot Army. Each device is used to flood a service with a specific type of traffic. DDoS attacks can be split into 3 different category types: - Volume Based Attacks - This attacks goal is to saturate the bandwidth of an attacked site. - UDP Floods, ICMP Floods and spoof-based attackeds are Volume attacks. - Measured in Bps (Bits per second) - Protocol Attacks - Protocol based attacks aim to consume up a victims resources. - SYN Flood, Ping of Death, Smurf DDoS are Protocol Attacks. - Measured in Pps (Packets per second) - Application Layer Attacks - Application Layer attacks aim to crash the web server - GET/POST Floods and typically attack Nginx, Apache, Windows, Linux based vulenerabilities. - Measuered in Rps (Requests per second)","title":"What is a DDoS Attack?"},{"location":"security/Network-Security/2022-04-20-netsec-ddos-attacks.html#types-of-ddos-attacks","text":"UDP Flood Floods a target with UDP packets on random ports on a host. This forces the host constantly check the application for the connection and when it doesnt find an active session it will respond with an ICMP \u2018Destination Unreachable\u2019 packet. This drains the resources of the target host. SYN Flood Floods a target with TCP SYN requests packets. This causes the host to respond with a SYN-ACK packet. The target ends ups waiting forever for an ACK from the attacker causing resources to be tied up until no new connections can be made. HTTP Flood Floods a target with GET or POST HTTP requests. These look legit so it is hard for a target host to determine what is legit or not. The goal is take utilize the resources on a host. ICMP Flood Overwhelms a target with ICMP Echo Request (ping) packets. The target host will attempt to reply to the attacker with ICMP Reply packets causing exhaustion of bandwidth and internal resources. Ping of Death (POD) The max size of an IP packet is 65,535 bytes. The data-link layer typically has a max frame size of 1500 bytes. This means a large IP packet has to be broken down into multiple fragments and then reassembled by the target host. If a host attempts to reassemble a packet larger than 65,535 bytes mememory buffer overflow errors can occur. Slowloris Allows a single computer to take down a webhost. Slowloris works by opening multiple connections to a web server and keeping them open as long as possible. Slowloris sends multiple HTTP headers for each request and never looks to complete the request. Eventually the connection pool on a host is filled and the target host can no longer accept new connections. Slowloris as the name states is meant to be a slow working attack. NTP Amplification An attacker will exploit a public NTP server and overhelm a victim host with UDP traffic. The amplification is due the fact that a compromised NTP host can easily send a very high amount of UDP traffic resulting in a high bandwidth & high volume attack. Smurf DDoS An attacker spoofs an IP address and sends an ICMP request to a victim. The victim will send a ICMP reply to which the attacker will echo the response back to the victim. This creates an infinite loop and eventually crashes the system.","title":"Types of DDoS Attacks"},{"location":"security/Network-Security/2022-04-20-netsec-ddos-attacks.html#mitigation-techniques","text":"There are many ways to mitigate a DDoS attack. Even more than listed here. I believe a good combination of a few in conjuction will help round out your networks defense to a DDoS attack. Anycast Network Anycast allows different servers to share the same IP address. BGP allows hosts to find the best route to the nearest anycast address. Anycast networks allows network traffic to be spread out. A DDoS attack would have to take down every server in the anycast network. Firewall & Network Monitoring Configure firewall to protect against flood attacks. Monitor traffic so you can keep traffic of patterns and determine when an attack is possible. Cloud Multi Region Hosted Application Have an application configured to work in different physical regions this way the blast radius would be large for a DDoS attack. Utilize BGP with an ISP Work with an ISP to route traffic away when a DDoS attack is detected. Upstream filtering Cloudflare or Amazon Shield work by checking incoming packet IPs against known attackers and BotNets and attempt to only forward legitimate traffic. Stops the attack before it reaches your network. CDN Network Avoids a single point of congestion by having multiple PoPs. Distributes content across the globe or regions. Anti DDoS Systems Arbor Networks, Akamai, CloudFlare, Radware","title":"Mitigation Techniques"},{"location":"security/Network-Security/2022-04-25-netsec-dns-spoofing.html","text":"DNS Spoofing # Todays topic DNS spoofing! I hope you all enjoy this one. What is DNS Spoofing? # A Distributed Denial of Service (DDoS) attack is a malicious network attack whose goal is to stop or interrupt an online application or service by overloading it's system. DDoS attacks are calculated and usualy come from multiple compromised hosts called a Bot Army. Each device is used to flood a service with a specific type of traffic. DDoS attacks can be split into 3 different category types: - Volume Based Attacks - This attacks goal is to saturate the bandwidth of an attacked site. - UDP Floods, ICMP Floods and spoof-based attackeds are Volume attacks. - Measured in Bps (Bits per second) - Protocol Attacks - Protocol based attacks aim to consume up a victims resources. - SYN Flood, Ping of Death, Smurf DDoS are Protocol Attacks. - Measured in Pps (Packets per second) - Application Layer Attacks - Application Layer attacks aim to crash the web server - GET/POST Floods and typically attack Nginx, Apache, Windows, Linux based vulenerabilities. - Measuered in Rps (Requests per second) Types of DDoS Attacks # UDP Flood Floods a target with UDP packets on random ports on a host. This forces the host constantly check the application for the connection and when it doesnt find an active session it will respond with an ICMP \u2018Destination Unreachable\u2019 packet. This drains the resources of the target host. SYN Flood Floods a target with TCP SYN requests packets. This causes the host to respond with a SYN-ACK packet. The target ends ups waiting forever for an ACK from the attacker causing resources to be tied up until no new connections can be made. HTTP Flood Floods a target with GET or POST HTTP requests. These look legit so it is hard for a target host to determine what is legit or not. The goal is take utilize the resources on a host. ICMP Flood Overwhelms a target with ICMP Echo Request (ping) packets. The target host will attempt to reply to the attacker with ICMP Reply packets causing exhaustion of bandwidth and internal resources. Ping of Death (POD) The max size of an IP packet is 65,535 bytes. The data-link layer typically has a max frame size of 1500 bytes. This means a large IP packet has to be broken down into multiple fragments and then reassembled by the target host. If a host attempts to reassemble a packet larger than 65,535 bytes mememory buffer overflow errors can occur. Slowloris Allows a single computer to take down a webhost. Slowloris works by opening multiple connections to a web server and keeping them open as long as possible. Slowloris sends multiple HTTP headers for each request and never looks to complete the request. Eventually the connection pool on a host is filled and the target host can no longer accept new connections. Slowloris as the name states is meant to be a slow working attack. NTP Amplification An attacker will exploit a public NTP server and overhelm a victim host with UDP traffic. The amplification is due the fact that a compromised NTP host can easily send a very high amount of UDP traffic resulting in a high bandwidth & high volume attack. Smurf DDoS An attacker spoofs an IP address and sends an ICMP request to a victim. The victim will send a ICMP reply to which the attacker will echo the response back to the victim. This creates an infinite loop and eventually crashes the system. Mitigation Techniques # There are many ways to mitigate a DDoS attack. Even more than listed here. I believe a good combination of a few in conjuction will help round out your networks defense to a DDoS attack. Anycast Network Anycast allows different servers to share the same IP address. BGP allows hosts to find the best route to the nearest anycast address. Anycast networks allows network traffic to be spread out. A DDoS attack would have to take down every server in the anycast network. Firewall & Network Monitoring Configure firewall to protect against flood attacks. Monitor traffic so you can keep traffic of patterns and determine when an attack is possible. Cloud Multi Region Hosted Application Have an application configured to work in different physical regions this way the blast radius would be large for a DDoS attack. Utilize BGP with an ISP Work with an ISP to route traffic away when a DDoS attack is detected. Upstream filtering Cloudflare or Amazon Shield work by checking incoming packet IPs against known attackers and BotNets and attempt to only forward legitimate traffic. Stops the attack before it reaches your network. CDN Network Avoids a single point of congestion by having multiple PoPs. Distributes content across the globe or regions. Anti DDoS Systems Arbor Networks, Akamai, CloudFlare, Radware","title":"DNS Spoofing"},{"location":"security/Network-Security/2022-04-25-netsec-dns-spoofing.html#dns-spoofing","text":"Todays topic DNS spoofing! I hope you all enjoy this one.","title":"DNS Spoofing"},{"location":"security/Network-Security/2022-04-25-netsec-dns-spoofing.html#what-is-dns-spoofing","text":"A Distributed Denial of Service (DDoS) attack is a malicious network attack whose goal is to stop or interrupt an online application or service by overloading it's system. DDoS attacks are calculated and usualy come from multiple compromised hosts called a Bot Army. Each device is used to flood a service with a specific type of traffic. DDoS attacks can be split into 3 different category types: - Volume Based Attacks - This attacks goal is to saturate the bandwidth of an attacked site. - UDP Floods, ICMP Floods and spoof-based attackeds are Volume attacks. - Measured in Bps (Bits per second) - Protocol Attacks - Protocol based attacks aim to consume up a victims resources. - SYN Flood, Ping of Death, Smurf DDoS are Protocol Attacks. - Measured in Pps (Packets per second) - Application Layer Attacks - Application Layer attacks aim to crash the web server - GET/POST Floods and typically attack Nginx, Apache, Windows, Linux based vulenerabilities. - Measuered in Rps (Requests per second)","title":"What is DNS Spoofing?"},{"location":"security/Network-Security/2022-04-25-netsec-dns-spoofing.html#types-of-ddos-attacks","text":"UDP Flood Floods a target with UDP packets on random ports on a host. This forces the host constantly check the application for the connection and when it doesnt find an active session it will respond with an ICMP \u2018Destination Unreachable\u2019 packet. This drains the resources of the target host. SYN Flood Floods a target with TCP SYN requests packets. This causes the host to respond with a SYN-ACK packet. The target ends ups waiting forever for an ACK from the attacker causing resources to be tied up until no new connections can be made. HTTP Flood Floods a target with GET or POST HTTP requests. These look legit so it is hard for a target host to determine what is legit or not. The goal is take utilize the resources on a host. ICMP Flood Overwhelms a target with ICMP Echo Request (ping) packets. The target host will attempt to reply to the attacker with ICMP Reply packets causing exhaustion of bandwidth and internal resources. Ping of Death (POD) The max size of an IP packet is 65,535 bytes. The data-link layer typically has a max frame size of 1500 bytes. This means a large IP packet has to be broken down into multiple fragments and then reassembled by the target host. If a host attempts to reassemble a packet larger than 65,535 bytes mememory buffer overflow errors can occur. Slowloris Allows a single computer to take down a webhost. Slowloris works by opening multiple connections to a web server and keeping them open as long as possible. Slowloris sends multiple HTTP headers for each request and never looks to complete the request. Eventually the connection pool on a host is filled and the target host can no longer accept new connections. Slowloris as the name states is meant to be a slow working attack. NTP Amplification An attacker will exploit a public NTP server and overhelm a victim host with UDP traffic. The amplification is due the fact that a compromised NTP host can easily send a very high amount of UDP traffic resulting in a high bandwidth & high volume attack. Smurf DDoS An attacker spoofs an IP address and sends an ICMP request to a victim. The victim will send a ICMP reply to which the attacker will echo the response back to the victim. This creates an infinite loop and eventually crashes the system.","title":"Types of DDoS Attacks"},{"location":"security/Network-Security/2022-04-25-netsec-dns-spoofing.html#mitigation-techniques","text":"There are many ways to mitigate a DDoS attack. Even more than listed here. I believe a good combination of a few in conjuction will help round out your networks defense to a DDoS attack. Anycast Network Anycast allows different servers to share the same IP address. BGP allows hosts to find the best route to the nearest anycast address. Anycast networks allows network traffic to be spread out. A DDoS attack would have to take down every server in the anycast network. Firewall & Network Monitoring Configure firewall to protect against flood attacks. Monitor traffic so you can keep traffic of patterns and determine when an attack is possible. Cloud Multi Region Hosted Application Have an application configured to work in different physical regions this way the blast radius would be large for a DDoS attack. Utilize BGP with an ISP Work with an ISP to route traffic away when a DDoS attack is detected. Upstream filtering Cloudflare or Amazon Shield work by checking incoming packet IPs against known attackers and BotNets and attempt to only forward legitimate traffic. Stops the attack before it reaches your network. CDN Network Avoids a single point of congestion by having multiple PoPs. Distributes content across the globe or regions. Anti DDoS Systems Arbor Networks, Akamai, CloudFlare, Radware","title":"Mitigation Techniques"}]}